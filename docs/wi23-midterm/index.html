<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Winter 2023 Midterm Exam</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/theme.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Winter 2023 Midterm Exam</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- add after bootstrap.min.css -->
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/>
<!-- add after bootstrap.min.js or bootstrap.bundle.min.js -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- for difficulty gauges-->
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../index.html">← return to practice.dsc80.com</a></p>
<hr />
<p><strong>Instructor(s):</strong> Suraj Rampure</p>
<p>This exam was administered in-person. The exam was closed-notes,
except students were allowed to bring a single two-sided notes sheet. No
calculators were allowed. Students had <strong>50 minutes</strong> to
take this exam.</p>
<hr />
<p><strong>Welcome to the Midterm Exam for DSC 80 in Winter
2023!</strong></p>
<p>Throughout this exam, we will work with the DataFrame
<code>tv</code>, which contains information about various TV shows
available to watch on streaming services. For each TV show, we have:</p>
<ul>
<li><code>"Title" (object)</code>: The title of the TV show.</li>
<li><code>"Year" (int)</code>: The year in which the TV show was first
released. (For instance, the show <em>How I Met Your Mother</em> ran
from 2005 to 2014; there is only one row for <em>How I Met Your
Mother</em> in <code>tv</code>, and its <code>"Year"</code> value is
2005.)</li>
<li><code>"Age" (object)</code>: The age category for the TV show. If
not missing, <code>"Age"</code> is one of <code>"all"</code>,
<code>"7+"</code>, <code>"13+"</code>, <code>"16+"</code>, or
<code>"18+"</code>. (For instance, <code>"all"</code> means that the
show is appropriate for all audiences, while `“18+”} means that the show
contains mature content and viewers should be at least 18 years
old.)</li>
<li><code>"IMDb" (float)</code>: The TV show’s rating on IMDb (between 0
and 10).</li>
<li><code>"Rotten Tomatoes" (int)</code>: The TV show’s rating on Rotten
Tomatoes (between 0 and 100).</li>
<li><code>"Netflix" (int)</code>: 1 if the show is available for
streaming on Netflix and 0 otherwise. The <code>"Hulu"</code>,
<code>"Prime Video"</code>, and <code>"Disney+"</code> columns work the
same way.</li>
</ul>
<p>The first few rows of <code>tv</code> are shown below (though
<code>tv</code> has many more rows than are pictured here).</p>
<center><img src='../assets/images/wi23-midterm/data-info-wi23-mt.png' width=65%></center>
<p>Assume that we have already run all of the necessary imports.</p>
<p><strong>Throughout this exam, we will refer to <code>tv</code>
repeatedly.</strong></p>
<hr />
<h2 id="problem-1">Problem 1</h2>
<p><br></p>
<h3 id="problem-1.1">Problem 1.1</h3>
<p>What kind of variable is <code>"Netflix"</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Quantitative discrete</p></li>
<li><p><input type="radio" disabled="" /> Quantitative continuous</p></li>
<li><p><input type="radio" disabled="" /> Qualitative ordinal</p></li>
<li><p><input type="radio" disabled="" /> Qualitative nominal</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_1" aria-expanded="true" aria-controls="collapse1_1">
Click to view the solution.
</button>
</h2>
<div id="collapse1_1" class="accordion-collapse collapse collapse"
aria-labelledby="heading1_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Quantitative discrete</p>
<p>Remember, a variable is quantitative (i.e. numerical) if arithmetic
operations have meaning. If we add up the values in the
<code>"Netflix"</code> column for a subset of the rows, we get the
number of TV shows in that subset that are available for streaming on
Netflix. If we take the average of the values in the
<code>"Netflix"</code> column for a subset of the rows, we get the
proportion of TV shows in that subset that are available for streaming
on Netflix. Since arithmetic operations have meaning,
<code>"Netflix"</code> is quantitative, and since it can only take on a
finite number of values (just 0 or 1) it is also discrete.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>In the following subparts, consider the variable
<code>double_count</code>, defined below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>double_count <span class="op">=</span> tv[<span class="st">&quot;Title&quot;</span>].value_counts().value_counts()</span></code></pre></div>
<p><br></p>
<h3 id="problem-1.2">Problem 1.2</h3>
<p>What is <code>type(double_count)</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Series</p></li>
<li><p><input type="radio" disabled="" /> SeriesGroupBy</p></li>
<li><p><input type="radio" disabled="" /> DataFrame</p></li>
<li><p><input type="radio" disabled="" /> DataFrameGroupBy</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_2" aria-expanded="true" aria-controls="collapse1_2">
Click to view the solution.
</button>
</h2>
<div id="collapse1_2" class="accordion-collapse collapse collapse"
aria-labelledby="heading1_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Series</p>
<p>The <code>.value_counts()</code> method, when called on a Series
<code>s</code>, produces a new Series in which</p>
<ul>
<li>the index contains all unique values in <code>s</code>.</li>
<li>the values are the frequencies of the unique values in
<code>s</code>.</li>
</ul>
<p>Since <code>tv["Title"]</code> is a Series,
<code>tv["Title"].value_counts()</code> is a Series, and so is
<code>tv["Title"].value_counts.value_counts()</code>. We provide an
interpretation of each of these Series in the solution to the next
subpart.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.3">Problem 1.3</h3>
<p>Which of the following statements are true? Select all that
apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> The only case in which it would make sense to set the index of
<code>tv</code> to <code>"Title"</code> is if
<code>double_count.iloc[0] == 1</code> is <code>True</code>.</p></li>
<li><p><input type="checkbox" disabled="" /> The only case in which it would make sense to set the index of
<code>tv</code> to <code>"Title"</code> is if
<code>double_count.loc[1] == tv.shape[0]</code> is
<code>True</code>.</p></li>
<li><p><input type="checkbox" disabled="" /> If <code>double_count.loc[2] == 5</code> is <code>True</code>, there
are 5 TV shows that all share the same <code>"Title"</code>.</p></li>
<li><p><input type="checkbox" disabled="" /> If <code>double_count.loc[2] == 5</code> is <code>True</code>, there
are 5 pairs of 2 TV shows such that each pair shares the same
<code>"Title"</code>.</p></li>
<li><p><input type="checkbox" disabled="" /> None of the above.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_3" aria-expanded="true" aria-controls="collapse1_3">
Click to view the solution.
</button>
</h2>
<div id="collapse1_3" class="accordion-collapse collapse collapse"
aria-labelledby="heading1_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers</strong>:</p>
<ul>
<li>The only case in which it would make sense to set the index of
<code>tv</code> to <code>"Title"</code> is if
<code>double_count.loc[1] == tv.shape[0]</code> is
<code>True</code>.</li>
<li>If <code>double_count.loc[2] == 5</code> is <code>True</code>, there
are 5 pairs of 2 TV shows such that each pair shares the same
<code>"Title"</code>.</li>
</ul>
<p>To answer, we need to understand what each of
<code>tv["Title"]</code>, <code>tv["Title"].value_counts()</code>, and
<code>tv["Title"].value_counts().value_counts()</code> contain.
<code>tv["Title"]</code>, as we know, contains the name of each TV
show.</p>
<p><code>tv["Title"].value_counts()</code> is a Series whose index is a
sequence of the unique TV show titles in <code>tv["Title"]</code>, and
whose values are the frequencies of each title.
<code>tv["Title"].value_counts()</code> may look something like the
following:</p>
<div id="cb1" class="sourceCode">
<pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a>Breaking Bad                             <span class="dv">1</span></span>
<span id="cb1-2"><a aria-hidden="true" href="#cb1-2" tabindex="-1"></a>Fresh Meat                               <span class="dv">1</span></span>
<span id="cb1-3"><a aria-hidden="true" href="#cb1-3" tabindex="-1"></a>Doctor Thorne                            <span class="dv">1</span></span>
<span id="cb1-4"><a aria-hidden="true" href="#cb1-4" tabindex="-1"></a>                                       ...</span>
<span id="cb1-5"><a aria-hidden="true" href="#cb1-5" tabindex="-1"></a>Styling Hollywood                        <span class="dv">1</span></span>
<span id="cb1-6"><a aria-hidden="true" href="#cb1-6" tabindex="-1"></a>Vai Anitta                               <span class="dv">1</span></span>
<span id="cb1-7"><a aria-hidden="true" href="#cb1-7" tabindex="-1"></a>Fearless Adventures <span class="cf">with</span> Jack Randall    <span class="dv">1</span></span>
<span id="cb1-8"><a aria-hidden="true" href="#cb1-8" tabindex="-1"></a>Name: Title, Length: <span class="dv">5368</span>, dtype: int64</span></code></pre>
</div>
<p>Then, <code>tv["Title"].value_counts().value_counts()</code> is a
Series whose index is a sequence of the unique values in the above
Series, and whose values are the frequencies of each value above. In the
case where all titles in <code>tv["Title"]</code> are unique, then
<code>tv["Title"].value_counts()</code> will only have one unique value,
1, repeated many times. Then,
<code>tv["Title"].value_counts().value_counts()</code> will only have
one row total, and will look something like:</p>
<div id="cb2" class="sourceCode">
<pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a aria-hidden="true" href="#cb2-1" tabindex="-1"></a><span class="dv">1</span>    <span class="dv">5368</span></span>
<span id="cb2-2"><a aria-hidden="true" href="#cb2-2" tabindex="-1"></a>Name: Title, dtype: int64</span></code></pre>
</div>
<p>This allows us to distinguish between the first two answer choices.
The key is remembering that <strong>in order to set a column to the
index, the column should only contain unique values</strong>, since the
goal of the index is to provide a “name” (more formally, a label) for
each row.</p>
<ul>
<li>The first answer choice, “The only case in which it would make sense
to set the index of <code>tv</code> to <code>"Title"</code> is if
<code>double_count.iloc[0] == 1</code> is <code>True</code>”, is false.
As we can see in the example above, all titles are unique, but
<code>double_count.iloc[0]</code> is something other than 1.</li>
<li>The second answer choice, “The only case in which it would make
sense to set the index of <code>tv</code> to <code>"Title"</code> is if
<code>double_count.loc[1] == tv.shape[0]</code> is <code>True</code>”,
is true. If <code>double_count.loc[1] == tv.shape[0]</code>, it means
that all values in <code>tv["Title"].value_counts()</code> were 1,
meaning that <code>tv["Title"]</code> consisted solely of unique values,
which is the only case in which it makes sense to set
<code>"Title"</code> to the index.</li>
</ul>
<p>Now, let’s look at the second two answer choices. If
<code>double_counts.loc[2] == 5</code>, it would mean that 5 of the
values in <code>tv["Title"].value_counts()</code> were 2. This would
mean that there were 5 pairs of titles in <code>tv["Title"]</code> that
were the same.</p>
<ul>
<li>This makes the fourth answer choice, “If
<code>double_count.loc[2] == 5</code> is <code>True</code>, there are 5
pairs of 2 TV shows such that each pair shares the same
<code>"Title"</code>”, correct.</li>
<li>The third answer choice, “If <code>double_count.loc[2] == 5</code>
is <code>True</code>, there are 5 TV shows that all share the same
<code>"Title"</code>”, is incorrect; if there were 5 TV shows with the
same title, then <code>double_count.loc[5]</code> would be at least 1,
but we can’t make any guarantees about
<code>double_counts.loc[2]</code>.</li>
</ul>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-2">Problem 2</h2>
<p>Ethan is an avid Star Wars fan, and the only streaming service he has
an account on is Disney+. (He had a Netflix account, but then Netflix
cracked down on password sharing.)</p>
<p>Fill in the blanks below so that <code>star_disney_prop</code>
evaluates to the proportion of TV shows in <code>tv</code> with
<code>"Star Wars"</code> in the title that are available to stream on
Disney+.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>star_only <span class="op">=</span> __(a)__</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>star_disney_prop <span class="op">=</span> __(b)__ <span class="op">/</span> star_only.shape[<span class="dv">0</span>]</span></code></pre></div>
<p>What goes in the blanks?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2" aria-expanded="true" aria-controls="collapse2">
Click to view the solution.
</button>
</h2>
<div id="collapse2" class="accordion-collapse collapse collapse"
aria-labelledby="heading2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers</strong>:</p>
<ul>
<li>Blank (a):
<code>tv[tv["Title"].str.contains("Star Wars")]</code></li>
<li>Blank (b): <code>star_only["Disney+"].sum()</code></li>
</ul>
<p>We’re asked to find the proportion of TV shows with
<code>"Star Wars"</code> in the title that are available to stream on
Disney+. This is a fraction, where:</p>
<ul>
<li>The numerator is the number of TV shows that have
<code>"Star Wars"</code> in the title <strong>and</strong> are available
to stream on Disney+.</li>
<li>The denominator is the number of TV shows that have
<code>"Star Wars"</code> in the title.</li>
</ul>
<p>The key is recognizing that <code>star_only</code> must be a
DataFrame that contains all the rows in which the <code>"Title"</code>
contains <code>"Star Wars"</code>; to create this DataFrame in blank
(a), we use <code>tv[tv["Title"].str.contains("Star Wars")]</code>.
Then, the denominator is already provided for us, and all we need to
fill in is the numerator. There are a few possibilities, though they all
include <code>star_only</code>:</p>
<ul>
<li><code>star_only["Disney+"].sum()</code></li>
<li><code>(star_only["Disney+"] == 1).sum()</code></li>
<li><code>star_only[star_only["Disney+"] == 1].shape[0]</code></li>
</ul>
<p><strong>Common misconception</strong>: Many students calculated the
wrong proportion: they calculated the proportion of shows available to
stream on Disney+ that have <code>"Star Wars"</code> in the title. We
asked for the proportion of shows with <code>"Star Wars"</code> in the
title that are available to stream on Disney+; “proportion of <span class="math inline">X</span> that <span class="math inline">Y</span>” is
always <span class="math inline">\frac{\# X \text{ and } Y}{\#
X}</span>.</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-3">Problem 3</h2>
<p>As you saw in the first few rows of <code>tv</code>, some TV shows
are available for streaming on multiple streaming services. Fill in the
blanks so that the two expressions below, Expression 1 and Expression 2,
<strong>both</strong> evaluate to the <code>"Title"</code> of the TV
show that is available for streaming on the <strong>greatest number of
streaming services</strong>. Assume there are no ties and that the
<code>"Title"</code> column contains unique values.</p>
<p>Expression 1:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>tv.set_index(<span class="st">&quot;Title&quot;</span>).loc[__(a)__].T.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>).idxmax()</span></code></pre></div>
<p>Expression 2:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        tv.assign(num_services<span class="op">=</span>tv.iloc[__(b)__].<span class="bu">sum</span>(__(c)__))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>            .sort_values(<span class="st">&quot;num_services&quot;</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>            .iloc[__(d)__]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<p><strong><em>Hint</em></strong>: <code>.T</code> transposes the rows
and columns of a DataFrame — the indexes of <code>df</code> are the
columns of <code>df.T</code> and vice versa.</p>
<p>What goes in the blanks?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3" aria-expanded="true" aria-controls="collapse3">
Click to view the solution.
</button>
</h2>
<div id="collapse3" class="accordion-collapse collapse collapse"
aria-labelledby="heading3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answers</strong>:</p>
<ul>
<li><ol type="a">
<li><code>:, "Netflix":</code> or some variation of that</li>
</ol></li>
<li><ol start="2" type="a">
<li><code>:, 5:</code> or some variation of that</li>
</ol></li>
<li><ol start="3" type="a">
<li><code>axis=1</code></li>
</ol></li>
<li><ol start="4" type="a">
<li><code>-1, 0</code></li>
</ol></li>
</ul>
<p>In Expression 1, keep in mind that <code>idxmax()</code> is a Series
method returns the index of the row with the maximum value. As such, we
can infer that Expression 1 sums the service-specific indicator columns
(that is, the columns <code>"Netflix"</code>, <code>"Hulu"</code>,
<code>"Prime Video"</code>, and <code>"Disney+"</code>) for each row and
returns the index of the row with the greatest sum. To do this, we need
the <code>loc</code> accessor to select all the service-specific
indicator columns, which we can do using <code>loc[:, "Netflix":]</code>
or
<code>loc[:, ["Netflix", "Hulu", "Prime Video", "Disney+"]]</code>.</p>
<p>When looking at Expression 2, we can split the problem into two
parts: the code inside the <code>assign</code> statement and the code
outside of it.</p>
<ul>
<li>Glancing at the code inside of the <code>assign</code> statement,
(and also noticing the variable <code>num_services</code>), we realize
that we, once again, want to sum up the values in the service-specific
indicator columns. We do this by first selecting the last four columns,
using <code>.iloc[:, 5:]</code> (notice the <code>iloc</code>), and then
summing over <code>axis=1</code>. We use <code>axis=1</code> (different
from <code>axis=0</code> in Expression 1), because unlike Expression 1,
we’re summing over each row, instead of each column. If there had not
been a <code>.T</code> in the code for Expression 1, we would’ve also
used <code>axis=1</code> in Expression 1.</li>
<li>Finally, we need to select the <code>"Title"</code> of the last row
in DataFrame in Expression 2, because <code>sort_values</code> sorts in
ascending order by default. The last row has an integer position of -1,
and the <code>"Title"</code> column has an integer position of 0, so we
use <code>iloc[-1, 0]</code>.</li>
</ul>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-4">Problem 4</h2>
<p>In 2020, during the early COVID era, popular shows like <em>Never
Have I Ever</em>, <em>The Last Dance</em>, and <em>The Queen’s
Gambit</em> were all released. What they all share in common, other than
high viewership numbers and popularity on social media, are high ratings
on both IMDb and Rotten Tomatoes.</p>
<p>Fill in the blank below so that <code>top_years</code> evaluates to
an <strong>array</strong> of the <strong>years</strong> in which
<strong>at least 5 TV shows with an IMDb rating of 9 or higher were
released</strong>.</p>
<pre><code>top_years = tv.groupby(&quot;Year&quot;).filter(____)[&quot;Year&quot;].unique()</code></pre>
<p>What goes in the blank?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4" aria-expanded="true" aria-controls="collapse4">
Click to view the solution.
</button>
</h2>
<div id="collapse4" class="accordion-collapse collapse collapse"
aria-labelledby="heading4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:
<code>lambda df: (df["IMDb"] &gt;= 9).sum() &gt;= 5</code></p>
<p>The <code>filter</code> method of a <code>DataFrameGroupBy</code>
object takes in a function. That function should itself take in a
DataFrame, corresponding to all of the rows for a particular
<code>"Year"</code>, and return either <code>True</code> or
<code>False</code>. The result,
<code>tv.groupby("Year").filter(&lt;our function&gt;)</code>, will be a
DataFrame containing only the rows in which the returned Boolean by our
function is <code>True</code>. For instance,
<code>tv.groupby("Year").filter(lambda df: df.shape[0] &gt;= 2)</code>
will contain all of the rows for <code>"Years"</code> with at least 2 TV
shows.</p>
<p>In our case, we want
<code>tv.groupby("Year").filter(&lt;our function&gt;)</code> to evaluate
to a DataFrame with all of the <code>"Years"</code> that have at least 5
TV shows that have an <code>"IMDb"</code> rating of at least 9 (since
the provided code afterwards, <code>["Year"].unique()</code>, finds all
of the unique <code>"Year"</code>s in the DataFrame we produce). If
<code>df</code> is a DataFrame of TV shows, then
<code>(df["IMDb"] &gt;= 9).sum()</code> is the number of TV shows in
that DataFrame with an <code>"IMDb"</code> rating of at least 9, and
<code>(df["IMDb"] &gt;= 9).sum() &gt;= 5</code> is <code>True</code>
only for DataFrames in which there are at least 5 TV shows with an
<code>"IMDb"</code> rating of at least 9. Thus, the answer we were
looking for is
<code>lambda df: (df["IMDb"] &gt;= 9).sum() &gt;= 5</code>.</p>
<p>Another good answer we saw was
<code>lambda df: df.loc[df["IMDb"] &gt;= 9, "Title"].nunique() &gt;= 5</code>.</p>
<p>Fun fact: In the DataFrame we used to produce the exam, the only year
that satisfied the above criteria was 2020!</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="problem-5">Problem 5</h2>
<p>For your convenience, the first few rows of <code>tv</code> are shown
again below.</p>
<center><img src='../assets/images/wi23-midterm/data-info-wi23-mt.png' width=65%></center>
<p>For the purposes of this question only, suppose we have also access
to another similar DataFrame, <code>movies</code>, which contains
information about a variety of movies. The information we have for each
movie in <code>movies</code> is the same as the information we have for
each TV show in <code>tv</code>, except for IMDb ratings, which are
missing from <code>movies</code>.</p>
<p>The first few rows of <code>movies</code> are shown below (though
<code>movies</code> has many more rows than are pictured here).</p>
<center><img src='../assets/images/wi23-midterm/movies-dinfo-wi23-mt.png' width=65%></center>
<p><br></p>
<h3 id="problem-5.1">Problem 5.1</h3>
<p>The function <code>total_null</code>, defined below, takes in a
DataFrame and returns the total number of null values in the
DataFrame.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>total_null <span class="op">=</span> <span class="kw">lambda</span> df: df.isna().<span class="bu">sum</span>().<span class="bu">sum</span>()</span></code></pre></div>
<p>Consider the function <code>delta</code>, defined below.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> delta(a, b):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    tv_a <span class="op">=</span> tv.head(a)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    movies_b <span class="op">=</span> movies.head(b)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    together <span class="op">=</span> pd.concat([tv_a, movies_b])</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_null(together) <span class="op">-</span> total_null(tv_a) <span class="op">-</span> total_null(movies_b)</span></code></pre></div>
<p>Which of the following functions is equivalent to
<code>delta</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>lambda a, b: a</code></p></li>
<li><p><input type="radio" disabled="" /> <code>lambda a, b: b</code></p></li>
<li><p><input type="radio" disabled="" /> <code>lambda a, b: 9 * a</code></p></li>
<li><p><input type="radio" disabled="" /> <code>lambda a, b: 8 * b</code></p></li>
<li><p><input type="radio" disabled="" /> <code>lambda a, b: min(9 * a, 8 * b)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_1" aria-expanded="true" aria-controls="collapse5_1">
Click to view the solution.
</button>
</h2>
<div id="collapse5_1" class="accordion-collapse collapse collapse"
aria-labelledby="heading5_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: <code>lambda a, b: b</code></p>
<p>Let’s understand what each function does.</p>
<ul>
<li><code>total_null</code> just counts all the null values in a
DataFrame.</li>
<li><code>delta</code> concatenates the first <code>a</code> rows of
<code>tv</code> with the first <code>b</code> rows of
<code>movies</code> <strong>vertically</strong>, that is, on top of one
another (over axis 0). It then returns the difference between the total
number of null values in the concatenated DataFrame and the total number
of null values in the first <code>a</code> rows of <code>tv</code> and
first <code>b</code> rows of <code>movies</code> – in other words, it
returns <strong>the number of null values that were added as a result of
the concatenation</strong>.</li>
</ul>
<p>The key here is recognizing that <code>tv</code> and
<code>movies</code> have all of the same column names,
<strong>except</strong> <code>movies</code> doesn’t have an
<code>"IMDb"</code> column. As a result, when we concatenate, the
<code>"IMDb"</code> column will contain null values for every row that
was originally from <code>movies</code>. Since <code>b</code> rows from
<code>movies</code> are in the concatenated DataFrame, <code>b</code>
new null values are introduced as a result of the concatenation, and
thus <code>lambda, a, b: b</code> does the same thing as
<code>delta</code>.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.2">Problem 5.2</h3>
<p>Fill in the blank to complete the implementation of the function
<code>size_of_merge</code>, which takes a string <code>col</code>,
corresponding to the name of a <strong>single</strong> column that is
shared between <code>tv</code> and <code>movies</code>, and returns the
<strong>number of rows in</strong> the DataFrame
<code>tv.merge(movies, on=col)</code>.</p>
<ul>
<li><p>For instance, <code>size_of_merge("Year")</code> should return
the number of rows in <code>tv.merge(movies, on="Year")</code>.</p></li>
<li><p>The purpose of this question is to have you think conceptually
about how merges work. As such, <strong>solutions containing
<code>merge</code> or <code>concat</code> will receive 0
points.</strong></p></li>
</ul>
<p><strong>What goes in the blank below?</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> size_of_merge(col):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (____).<span class="bu">sum</span>()</span></code></pre></div>
<p><strong><em>Hint</em></strong>: Consider the behavior below.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> s1 <span class="op">=</span> pd.Series({<span class="st">&#39;a&#39;</span>: <span class="dv">2</span>, <span class="st">&#39;b&#39;</span>: <span class="dv">3</span>})</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> s2 <span class="op">=</span> pd.Series({<span class="st">&#39;c&#39;</span>: <span class="dv">4</span>, <span class="st">&#39;a&#39;</span>: <span class="op">-</span><span class="dv">1</span>, <span class="st">&#39;b&#39;</span>: <span class="dv">4</span>})</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> s1 <span class="op">*</span> s2</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>a    <span class="op">-</span><span class="fl">2.0</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>b    <span class="fl">12.0</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>c     NaN</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>dtype: float64</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_2" aria-expanded="true" aria-controls="collapse5_2">
Click to view the solution.
</button>
</h2>
<div id="collapse5_2" class="accordion-collapse collapse collapse"
aria-labelledby="heading5_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:
<code>tv[col].value_counts() * movies[col].value_counts()</code></p>
<p><code>tv.merge(movies, on=col)</code> contains one row for every
“match” between <code>tv[col]</code> and <code>movies[col]</code>.
Suppose, for example, that <code>col="Year"</code>. If
<code>tv["Year"]</code> contains 30 values equal to 2019, and
<code>movies["Year"]</code> contains 5 values equal to 2019,
<code>tv.merge(movies, on="Year")</code> will contain <span class="math inline">30 \cdot 5 = 150</span> rows in which the
<code>"Year"</code> value is equal to 2019 – one for every combination
of a 2019 row in <code>tv</code> and a 2019 row in
<code>movies</code>.</p>
<p><code>tv["Year"].value_counts()</code> and
<code>movies["Year"].value_counts()</code> contain, respectively, the
frequencies of the unique values in <code>tv["Year"]</code> and
<code>movies["Year"]</code>. Using the 2019 example from above,
<code>tv["Year"].value_counts() * movies["Year"].value_counts()</code>
will contain a row whose index is 2019 and whose value is 150, with
similar other entries for the other years in the two Series. (The hint
is meant to demonstrate the fact that no matter how the two Series are
sorted, the product is done element-wise by matching up indexes.) Then,
<code>(tv["Year"].value_counts() * movies["Year"].value_counts()).sum()</code>
will sum these products across all years, ignoring null values.</p>
<p>As such, the answer we were looking for is
<code>tv[col].value_counts() * movies[col].value_counts()</code>
(remember, <code>"Year"</code> was just an example for this
explanation).</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-6">Problem 6</h2>
<p>For the remainder of the exam, we will only consider TV shows that
are available to stream <em>exclusively</em> on a single streaming
service. The DataFrame <code>tv_excl</code> contains all of the
information we have for these TV shows. Note that instead of containing
separate columns for each streaming service, as <code>tv</code> did,
<code>tv_excl</code> instead has a single <code>"Service"</code> column
that contains the name of the one streaming service that the TV show is
available for streaming on.</p>
<p>The first few rows of <code>tv_excl</code> are shown below (though,
of course, <code>tv_excl</code> has many more rows than are pictured
here). Note that <em>Being Erica</em> is not in <code>tv_excl</code>,
since it is available to stream on multiple services.</p>
<center><img src='../assets/images/wi23-midterm/tv-excl.png' width=65%></center>
<p><br></p>
<h3 id="problem-6.1">Problem 6.1</h3>
<p>The DataFrame <code>counts</code>, shown in full below, contains the
number of TV shows for every combination of <code>"Age"</code> and
<code>"Service"</code>.</p>
<center><img src='../assets/images/wi23-midterm/pivot.png' width=40%></center>
<p>Given the above information, what does the following expression
evaluate to?</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>tv_excl.groupby([<span class="st">&quot;Age&quot;</span>, <span class="st">&quot;Service&quot;</span>]).<span class="bu">sum</span>().shape[<span class="dv">0</span>]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> 4</p></li>
<li><p><input type="radio" disabled="" /> 5</p></li>
<li><p><input type="radio" disabled="" /> 12</p></li>
<li><p><input type="radio" disabled="" /> 16</p></li>
<li><p><input type="radio" disabled="" /> 18</p></li>
<li><p><input type="radio" disabled="" /> 20</p></li>
<li><p><input type="radio" disabled="" /> 25</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_1" aria-expanded="true" aria-controls="collapse6_1">
Click to view the solution.
</button>
</h2>
<div id="collapse6_1" class="accordion-collapse collapse collapse"
aria-labelledby="heading6_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: 18</p>
<p>Note that the DataFrame <code>counts</code> is a pivot table, created
using
<code>tv_excl.pivot_table(index="Age", columns="Service", aggfunc="size")</code>.
As we saw in lecture, pivot tables contain the same information as the
result of grouping on two columns.</p>
<p>The DataFrame <code>tv_excl.groupby(["Age", "Service"]).sum()</code>
will have one row for every unique combination of <code>"Age"</code> and
<code>"Service"</code> in <code>tv_excl</code>. (The same is true even
if we used a different aggregation method, like <code>.mean()</code> or
<code>.max()</code>.) As <code>counts</code> shows us,
<code>tv_excl</code> contains every possible combination of a single
element in {<code>"13+"</code>, <code>"16+"</code>, <code>"18+"</code>,
<code>"7+"</code>, <code>"all"</code>} with a single element in
{<code>"Disney+"</code>, <code>"Hulu"</code>, <code>"Netflix"</code>,
<code>"Prime Video"</code>}, except for (<code>"13+"</code>,
<code>"Disney+"</code>) and (<code>"18+"</code>,
<code>"Disney+"</code>), which were not present in <code>tv_excl</code>;
if they were, they would have non-null values in
<code>counts</code>.</p>
<p>As such, <code>tv_excl.groupby(["Age", "Service"]).sum()</code> will
have <span class="math inline">20 - 2 = 18</span> rows, and
<code>tv_excl.groupby(["Age", "Service"]).sum().shape[0]</code>
evaluates to 18.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.2">Problem 6.2</h3>
<p>Tiffany would like to compare the distribution of <code>"Age"</code>
for Hulu and Netflix. Specifically, she’d like to test the following
hypotheses:</p>
<ul>
<li><p><strong>Null Hypothesis</strong>: The distributions of
<code>"Age"</code> for Hulu and Netflix are drawn from the same
population distribution, and any observed differences are due to random
chance.</p></li>
<li><p><strong>Alternative Hypothesis</strong>: The distributions of
<code>"Age"</code> for Hulu and Netflix are drawn from different
population distributions.</p></li>
</ul>
<p>What type of test is this?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Hypothesis test</p></li>
<li><p><input type="radio" disabled="" /> Permutation test</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_2" aria-expanded="true" aria-controls="collapse6_2">
Click to view the solution.
</button>
</h2>
<div id="collapse6_2" class="accordion-collapse collapse collapse"
aria-labelledby="heading6_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Permutation test</p>
<p>A permutation test is a statistical test in which we aim to determine
if two samples look like they were drawn from the same unknown
population. Here, our two samples are the distribution of
<code>"Age"</code>s for Hulu and the distribution of <code>"Age"</code>s
for Netflix.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.3">Problem 6.3</h3>
<p>Consider the DataFrame <code>distr</code>, defined below.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>hn <span class="op">=</span> counts[[<span class="st">&quot;Hulu&quot;</span>, <span class="st">&quot;Netflix&quot;</span>]]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>distr <span class="op">=</span> (hn <span class="op">/</span> hn.<span class="bu">sum</span>()).T  <span class="co"># Note that distr has 2 rows and 5 columns.</span></span></code></pre></div>
<p>To test the hypotheses in part (b), Tiffany decides to use the total
variation distance as her test statistic. Which of the following
expressions <strong>DO NOT</strong> correctly compute the observed
statistic for her test? Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>distr.diff().iloc[-1].abs().sum() / 2</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>distr.diff().sum().abs().sum() / 2</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>distr.diff().sum().sum().abs() / 2</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>(distr.sum() - 2 * distr.iloc[0]).abs().sum() / 2</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>distr.diff().abs().sum(axis=1).iloc[-1] / 2</code></p></li>
<li><p><input type="checkbox" disabled="" /> None of the above: all above options correctly compute the observed
statistic.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_3" aria-expanded="true" aria-controls="collapse6_3">
Click to view the solution.
</button>
</h2>
<div id="collapse6_3" class="accordion-collapse collapse collapse"
aria-labelledby="heading6_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:
<code>distr.diff().sum().sum().abs() / 2</code> only</p>
<p>First, note that the difference between the TVD calculation here and
those in lecture is that our pivot table contains one
<strong>row</strong> for each distribution, rather than one
<strong>column</strong> for each distribution. This is because of the
<code>.T</code> in the code snippet above. <code>distr</code> may look
something like:</p>
<center><img src="../assets/images/wi23-midterm/distr.png" width="50%"/></center>
<p><br/></p>
<p>As such, here we need to apply the <code>.diff()</code> method to
each column first, not each row (meaning we should supply
<code>axis=0</code> to <code>diff</code>, not <code>axis=1</code>;
<code>axis=0</code> is the default, so we don’t need to explicitly
specify it). <code>distr.diff()</code> may look something like:</p>
<center><img src="../assets/images/wi23-midterm/distr-diff.png" width="50%"/></center>
<p><br/></p>
<p>With that in mind, let’s look at each option, remembering that the
TVD is the <strong>sum of the absolute differences in proportions,
divided by 2</strong>.</p>
<ul>
<li><code>distr.diff().iloc[-1].abs().sum() / 2</code>:
<ul>
<li><code>distr.diff().iloc[-1]</code> contains the differences in
proportions.</li>
<li><code>distr.diff().iloc[-1].abs()</code> contains the absolute
differences in proportions.</li>
<li><code>distr.diff().iloc[-1].abs().sum() / 2</code> contains the sum
of the absolute differences in proportions, divided by 2. <strong>This
is the TVD.</strong></li>
</ul></li>
<li><code>distr.diff().sum().abs().sum() / 2</code>:
<ul>
<li><code>distr.diff().sum()</code> is a Series containing just the last
row in <code>distr.diff()</code>; remember, null values are ignored when
using methods such as <code>.mean()</code> and <code>.sum()</code>.</li>
<li><code>distr.diff().sum().abs()</code> contains the absolute
differences in proportions, and hence
<code>distr.diff().sum().abs().sum() / 2</code> contains the sum of the
absolute differences in proportions, divided by 2. <strong>This is the
TVD.</strong></li>
</ul></li>
<li><code>distr.diff().sum().sum().abs() / 2</code>:
<ul>
<li><code>distr.diff().sum()</code> contains the differences in
proportions (explained above).</li>
<li><code>distr.diff().sum().sum()</code> contains the sum of the
differences in proportions. <strong>This is 0</strong>; remember, the
reason we use the absolute value is to prevent the positive and negative
differences in proportions from cancelling each other out. As a result,
this option <strong>does not compute the TVD</strong>; in fact, it
errors, because <code>distr.diff().sum().sum()</code> is a single
<code>float</code>, and <code>float</code>s don’t have an
<code>.abs()</code> method.</li>
</ul></li>
<li><code>(distr.sum() - 2 * distr.iloc[0]).abs().sum() / 2</code>:
<ul>
<li>This option seems strange, but does actually compute the TVD. The
key idea is the fact that <span class="math inline">a - b</span> is the
same as <span class="math inline">(a + b) - 2 \cdot b)</span>.
<code>distr.sum()</code> is the same as
<code>distr.iloc[0] + distr.iloc[1]</code>, so
<code>distr.sum() - 2 * distr.iloc[0]</code> is
<code>distr.iloc[0] + distr.iloc[1] - 2 * distr.iloc[0]</code> which is
<code>distr.iloc[1] - distr.iloc[0]</code>, which is just
<code>distr.diff().iloc[-1]</code>.</li>
<li>Then, this option reduces to
<code>distr.diff().iloc[-1].abs().sum() / 2</code>, which is the same as
Option 1. <strong>This is the TVD.</strong></li>
</ul></li>
<li><code>distr.diff().abs().sum(axis=1).iloc[-1] / 2</code>:
<ul>
<li><code>distr.diff().abs()</code> is a DataFrame in which the last row
contains the absolute differences in proportions.</li>
<li><code>distr.diff().abs().sum(axis=1)</code> is a Series in which the
first element is null and the second element is the sum of the absolute
differences in proportions.</li>
<li>As such, <code>distr.diff().abs().sum(axis=1).iloc[-1] / 2</code> is
the sum of the absolute differences in proportions divided by 2.
<strong>This is the TVD.</strong></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<p><br></p>
<p>Doris proposes a novel approach for testing the hypotheses in part
(b). She proposes we compute the distribution of <code>"Age"</code> for
all TV shows in <code>tv_excl</code>, ignoring the streaming service
they’re available on. Then, she suggests we run two separate tests of
the following hypotheses, using the same significance level as used for
the tests in part (b):</p>
<ul>
<li><p><strong>Null Hypothesis</strong>: The distribution of
<code>"Age"</code> for service <span class="math inline">X</span> is
drawn from the distribution of <code>"Age"</code> for all services we
have data for.</p></li>
<li><p><strong>Alternative Hypothesis</strong>: The distribution of
<code>"Age"</code> for service <span class="math inline">X</span> is not
drawn from the distribution of <code>"Age"</code> for all services we
have data for.</p></li>
</ul>
<p>She suggests we test the above pair of hypotheses separately for Hulu
and Netflix, and gives the following interpretations:</p>
<ol type="1">
<li><p>If we fail to reject both null hypotheses here, we can also fail
to reject the null hypothesis in part (b).</p></li>
<li><p>If we reject both null hypotheses here, we can also reject the
null hypothesis in part (b).</p></li>
</ol>
<p><br></p>
<h3 id="problem-6.4">Problem 6.4</h3>
<p>What type of test is Doris proposing we run?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Hypothesis test</p></li>
<li><p><input type="radio" disabled="" /> Permutation test</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_4" aria-expanded="true" aria-controls="collapse6_4">
Click to view the solution.
</button>
</h2>
<div id="collapse6_4" class="accordion-collapse collapse collapse"
aria-labelledby="heading6_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Hypothesis test</p>
<p>A hypothesis test is a statistical test in which we aim to determine
whether a sample looks like it was drawn at random from a known
population. Here, Doris is proposing we run two separate hypothesis
tests: one in which we determine whether the distribution of
<code>"Age"</code> for Hulu (sample) is drawn from the distribution of
<code>"Age"</code> in our entire dataset (population), and one in which
we determine whether the distribution of <code>"Age"</code> for Netflix
(sample) is drawn from the distribution of <code>"Age"</code> in our
entire dataset (population).</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.5">Problem 6.5</h3>
<p>Which of Doris’ interpretations are valid? Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Interpretation 1: If we fail to reject both null hypotheses here,</p></li>
<li><p><input type="checkbox" disabled="" /> Interpretation 2: If we reject both null hypotheses here, we can
also</p></li>
<li><p><input type="checkbox" disabled="" /> Neither interpretation is valid.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_5" aria-expanded="true" aria-controls="collapse6_5">
Click to view the solution.
</button>
</h2>
<div id="collapse6_5" class="accordion-collapse collapse collapse"
aria-labelledby="heading6_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Interpretation 1 only</p>
<p>Let’s consider each option.</p>
<ul>
<li><strong>Interpretation 1</strong>: Suppose we fail to reject both
null hypotheses here. If that’s the case, then the distribution of
<code>"Age"</code> for Hulu <em>looks</em> like a random sample from the
distribution of <code>"Age"</code> in our full dataset, and so does the
distribution of <code>"Age"</code> for Netflix. (Note that we can’t
conclude they <em>are</em> random samples from the distribution of
<code>"Age"</code> in our full dataset, since we can’t prove the null,
we can only fail to reject it). If that’s the case, the distributions of
<code>"Age"</code> for Hulu and Netflix both look like they’re drawn
from the same population, which means we fail to reject the null from
Problem 6.2.</li>
<li><strong>Interpretation 2</strong>: Suppose we reject both null
hypotheses here. If that’s the case, then neither the distribution of
<code>"Age"</code> for Hulu nor the distribution of <code>"Age"</code>
for Netflix look like a random sample of <code>"Age"</code> in our full
dataset. However, that doesn’t imply that these two distributions don’t
look like samples of the same population; all it implies is that they
don’t look like samples of this particular population. It is still
possible that there exists some population distribution that the
distributions of <code>"Age"</code> for Hulu and Netflix both look like
they’re drawn from, which means we can’t automatically reject the null
from Problem 6.2.</li>
</ul>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-7">Problem 7</h2>
<p>The <code>"IMDb"</code> column in <code>tv_excl</code> contains
several missing values.</p>
<p><strong><em>Note</em></strong>: Answer each subpart of this question
independently of other subparts.</p>
<p><br></p>
<h3 id="problem-7.1">Problem 7.1</h3>
<p>Given no other information other than a TV show’s
<code>"Title"</code> and <code>"IMDb"</code> rating, what is the most
likely missingness mechanism of the <code>"IMDb"</code> column?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Missing by design</p></li>
<li><p><input type="radio" disabled="" /> Not missing at random</p></li>
<li><p><input type="radio" disabled="" /> Missing at random</p></li>
<li><p><input type="radio" disabled="" /> Missing completely at random</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_1" aria-expanded="true" aria-controls="collapse7_1">
Click to view the solution.
</button>
</h2>
<div id="collapse7_1" class="accordion-collapse collapse collapse"
aria-labelledby="heading7_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>:</p>
<ul>
<li>Full credit: Not missing at random</li>
<li>Partial credit: Missing completely at random</li>
</ul>
<p>The answer we were looking for is not missing at random (NMAR). As we
saw repeatedly in lectures and Lab 5, in cases where all we have access
to is a single column with missing values, potentially with other
unrelated columns (like <code>"Title"</code> here), the best explanation
is that there is some inherent reason as to why the values in the column
with missing values are missing. Here, a reasonable interpretation is
that the <code>"IMDb"</code> scores that are missing are likely to come
from worse TV shows, and so lower scores are more likely to be missing.
Think about it like this – if a TV show is really great, presumably more
people would know about it, and it would be rated. If a TV show wasn’t
as good and wasn’t as popular, it is more likely to be ignored.</p>
<p>However, partial credit was awarded to those who answered missing
completely at random.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.2">Problem 7.2</h3>
<p>Now, suppose we discover that the median
<code>"Rotten Tomatoes"</code> rating among TV shows with a missing
<code>"IMDb"</code> rating is a 13, while the median
<code>"Rotten Tomatoes"</code> rating among TV shows with a present
<code>"IMDb"</code> rating is a 52.</p>
<p>Given this information, what is the most likely missingness mechanism
of the <code>"IMDb"</code> column?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Missing by design</p></li>
<li><p><input type="radio" disabled="" /> Not missing at random</p></li>
<li><p><input type="radio" disabled="" /> Missing at random</p></li>
<li><p><input type="radio" disabled="" /> Missing completely at random</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_2" aria-expanded="true" aria-controls="collapse7_2">
Click to view the solution.
</button>
</h2>
<div id="collapse7_2" class="accordion-collapse collapse collapse"
aria-labelledby="heading7_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Missing at random</p>
<p>The problem tells us that the distribution of
<code>"Rotten Tomatoes"</code> when <code>"IMDb"</code> is missing (mean
13) is very different from the distribution of
<code>"Rotten Tomatoes"</code> when <code>"IMDb"</code> is not missing
(mean 52). As such, the missingness of <code>"IMDb"</code> appears to
depend on <code>"Rotten Tomatoes"</code>, and so the most likely
missingness mechanism is missing at random.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.3">Problem 7.3</h3>
<p>Suppose we want to perform a statistical test to determine whether
the missingness of <code>"IMDb"</code> depends on <code>"Age"</code>.
Which of the following test statistics could we use? Select all that
apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Difference in means</p></li>
<li><p><input type="checkbox" disabled="" /> Absolute difference in means</p></li>
<li><p><input type="checkbox" disabled="" /> Total variation distance</p></li>
<li><p><input type="checkbox" disabled="" /> The Kolmogorov-Smirnov statistic</p></li>
<li><p><input type="checkbox" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_3" aria-expanded="true" aria-controls="collapse7_3">
Click to view the solution.
</button>
</h2>
<div id="collapse7_3" class="accordion-collapse collapse collapse"
aria-labelledby="heading7_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: Total variation distance only</p>
<p>Our permutation test here needs to compare two distributions:</p>
<ul>
<li>The distribution of <code>"Age"</code> when <code>"IMDb"</code> is
missing.</li>
<li>The distribution of <code>"Age"</code> when <code>"IMDb"</code> is
not missing.</li>
</ul>
<p>Since <code>"Age"</code> is a categorical variable – remember, its
only possible values are <code>"7+"</code>, <code>"13+"</code>,
<code>"16+"</code>, <code>"18+"</code>, and <code>"all"</code> – the
above two distributions are categorical. The only test statistic of the
options provided that compares categorical distributions is the total
variation distance.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.4">Problem 7.4</h3>
<p>To determine whether the missingness of <code>"IMDb"</code> depends
on <code>"Year"</code>, we produce the following plot.</p>
<center><img src='../assets/images/wi23-midterm/year-imdb.png' width=50%></center>
<p>Suppose we want to perform a statistical test to determine whether
the two distributions above come from the same population distribution.
Which test statistic is most likely to yield a significant result?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Difference in means</p></li>
<li><p><input type="radio" disabled="" /> Absolute difference in means</p></li>
<li><p><input type="radio" disabled="" /> Total variation distance</p></li>
<li><p><input type="radio" disabled="" /> The Kolmogorov-Smirnov statistic</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_4" aria-expanded="true" aria-controls="collapse7_4">
Click to view the solution.
</button>
</h2>
<div id="collapse7_4" class="accordion-collapse collapse collapse"
aria-labelledby="heading7_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer</strong>: The Kolmogorov-Smirnov statistic</p>
<p>First, note that the two distributions are quantitative, which means
the TVD can’t be used here (the TVD only measures the difference between
two categorical distributions).</p>
<p>To decide between the remaining options, note that the two
distributions visualized appear to have the same mean, but different
shapes. The Kolmogorov-Smirnov statistic is designed to detect
differences in the shapes of distributions with the same center, and as
such, it is the most likely to yield a significant result here. The
others may not; since the means of the two distributions are very
similar, the observed difference in means will be close to 0, which is a
typical value under the null.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.5">Problem 7.5</h3>
<p>To determine whether the missingness of <code>"IMDb"</code> depends
on <code>"Service"</code>, we produce the following plot.</p>
<center><img src='../assets/images/wi23-midterm/service-imdb.png' width=50%></center>
<p>We’d like to fill in missing <code>"IMDb"</code> values in the
fastest, most efficient way possible, such that the mean of the imputed
<code>"IMDb"</code> column is as close to the true mean of the
<code>"IMDb"</code> column in nature as possible. Which imputation
technique should we use?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Unconditional mean imputation</p></li>
<li><p><input type="radio" disabled="" /> Mean imputation, conditional on <code>"Service"</code></p></li>
<li><p><input type="radio" disabled="" /> Unconditional probabilistic imputation</p></li>
<li><p><input type="radio" disabled="" /> Probabilistic imputation, conditional on <code>"Service"</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_5" aria-expanded="true" aria-controls="collapse7_5">
Click to view the solution.
</button>
</h2>
<div id="collapse7_5" class="accordion-collapse collapse collapse"
aria-labelledby="heading7_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p>Since the missingness of <code>"IMDb"</code> appears to depend on
<code>"Service"</code>, in order to accurately estimate the true mean of
the <code>"IMDb"</code> column, we must impute conditionally on
<code>"Service"</code>, otherwise the imputed mean will be biased.</p>
<p>To decide between conditional mean imputation and conditional
probabilistic imputation, note that we were asked to find the
<strong>fasted, most efficient</strong> technique possible, such that
the imputed mean is close to the true mean. Conditional mean imputation
is more efficient than conditional probabilistic imputation, as
probabilistic imputation requires sampling. While mean imputation
shrinks the variance of the imputed distribution relative to the true
distribution, we weren’t asked to preserve the variance of the true
distribution, so conditional mean imputation is the right choice.</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="section"><span class="math display"> </span></h2>
<h4
id="feedback-find-an-error-still-confused-have-a-suggestion-let-us-know-here.">👋
Feedback: Find an error? Still confused? Have a suggestion?
<a href="https://forms.gle/WZ71FchnXU1K154d7">Let us know
here</u></a>.</h4>
<hr />
</body>
</html>
