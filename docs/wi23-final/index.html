<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Winter 2023 Final Exam</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/theme.css" />
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Winter 2023 Final Exam</h1>
</header>
<p><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<!-- add after bootstrap.min.css -->
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css"/>
<!-- add after bootstrap.min.js or bootstrap.bundle.min.js -->
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script></p>
<!-- for difficulty gauges-->
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-B947E6J6H4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-B947E6J6H4');
</script>
<p><a href="../index.html">← return to practice.dsc80.com</a></p>
<hr />
<p><strong>Instructor(s):</strong> Suraj Rampure</p>
<p>This exam was administered in-person. The exam was closed-notes,
except students were allowed to bring 2 two-sided cheat sheets. No
calculators were allowed. Students had <strong>180 minutes</strong> to
take this exam.</p>
<hr />
<p>The DataFrame <code>sat</code> contains one row for
<strong>most</strong> combinations of <code>"Year"</code> and
<code>"State"</code>, where <code>"Year"</code> ranges between
<code>2005</code> and <code>2015</code> and <code>"State"</code> is one
of the 50 states (not including the District of Columbia).</p>
<p>The other columns are as follows:</p>
<ul>
<li><p><code>"# Students"</code> contains the number of students who
took the SAT in that state in that year.</p></li>
<li><p><code>"Math"</code> contains the mean math section score among
all students who took the SAT in that state in that year. This ranges
from 200 to 800.</p></li>
<li><p><code>"Verbal"</code> contains the mean verbal section score
among all students who took the SAT in that state in that year. This
ranges from 200 to 800. (This is now known as the “Critical Reading”
section.)</p></li>
</ul>
<p>The first few rows of <code>sat</code> are shown below (though
<code>sat</code> has many more rows than are pictured here).</p>
<center><img src='../assets/images/wi23-final/df.png' width=40%></center>
<p>For instance, the first row of <code>sat</code> tells us that 41227
students took the SAT in Washington in 2014, and among those students,
the mean math score was 519 and the mean verbal score was 510.</p>
<p>Assume:</p>
<ul>
<li><p><code>sat</code> does not contain any duplicate rows — that is,
there is only one row for every unique combination of
<code>"Year"</code> and <code>"State"</code> that is in
<code>sat</code>.</p></li>
<li><p><code>sat</code> does not contain any null values.</p></li>
<li><p>We have already run all of the necessary imports.</p></li>
</ul>
<hr />
<h2 id="problem-1">Problem 1</h2>
<p><br></p>
<h3 id="problem-1.1">Problem 1.1</h3>
<p>Which of the following expressions evaluate to the name of the state,
as a string, with the highest mean math section score in 2007? Select
all that apply.</p>
<p><em>Note: Assume that the highest mean math section score in 2007 was
unique to only one state.</em></p>
<p>Option 1:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(sat.loc[(sat[<span class="st">&quot;Math&quot;</span>] <span class="op">==</span> sat[<span class="st">&quot;Math&quot;</span>].<span class="bu">max</span>()) <span class="op">&amp;</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>       (sat[<span class="st">&quot;Year&quot;</span>] <span class="op">==</span> <span class="dv">2007</span>), <span class="st">&quot;State&quot;</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>.iloc[<span class="dv">0</span>])</span></code></pre></div>
<p>Option 2:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>sat.loc[sat[<span class="st">&quot;Year&quot;</span>] <span class="op">==</span> <span class="dv">2007</span>].set_index(<span class="st">&quot;State&quot;</span>)[<span class="st">&quot;Math&quot;</span>].idxmax()</span></code></pre></div>
<p>Option 3:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>sat.groupby(<span class="st">&quot;Year&quot;</span>)[<span class="st">&quot;State&quot;</span>].<span class="bu">max</span>().loc[<span class="dv">2007</span>]</span></code></pre></div>
<p>Option 4:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(sat.loc[sat[<span class="st">&quot;Math&quot;</span>] <span class="op">==</span> sat.loc[sat[<span class="st">&quot;Year&quot;</span>] <span class="op">==</span> <span class="dv">2007</span>, <span class="st">&quot;Math&quot;</span>].<span class="bu">max</span>()]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>   .iloc[<span class="dv">0</span>]  </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>   .loc[<span class="st">&quot;State&quot;</span>])</span></code></pre></div>
<p>Option 5:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(sat.groupby(<span class="st">&quot;Year&quot;</span>).<span class="bu">apply</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> sat: sat[sat[<span class="st">&quot;Math&quot;</span>] <span class="op">==</span> sat[<span class="st">&quot;Math&quot;</span>].<span class="bu">max</span>()]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>.groupby(<span class="st">&quot;Year&quot;</span>)[<span class="st">&quot;State&quot;</span>].<span class="bu">max</span>()</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>.loc[<span class="dv">2007</span>])</span></code></pre></div>
<p>Option 6:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>sat.loc[sat[<span class="st">&#39;Year&#39;</span>] <span class="op">==</span> <span class="dv">2007</span>].loc[sat[<span class="st">&#39;Math&#39;</span>] <span class="op">==</span> sat[<span class="st">&#39;Math&#39;</span>].<span class="bu">max</span>()]</span></code></pre></div>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> Option 1</p></li>
<li><p><input type="checkbox" disabled="" /> Option 2</p></li>
<li><p><input type="checkbox" disabled="" /> Option 3</p></li>
<li><p><input type="checkbox" disabled="" /> Option 4</p></li>
<li><p><input type="checkbox" disabled="" /> Option 5</p></li>
<li><p><input type="checkbox" disabled="" /> Option 6</p></li>
<li><p><input type="checkbox" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_1" aria-expanded="true" aria-controls="collapse1_1">
Click to view the solution.
</button>
</h2>
<div id="collapse1_1" class="accordion-collapse collapse"
aria-labelledby="heading1_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 2 and Option 5</p>
<p>Option 1:
<code>(sat.loc[(sat["Math"] == sat["Math"].max()) &amp; (sat["Year"] == 2007), "State"].iloc[0])</code>
This expression looks for entries where the math score equals the
overall max <code>"Math"</code> score in the dataset and the year is
2007. However, this approach has a limitation: it assumes that the
highest math score in the entire dataset occurred in 2007.</p>
<p>Option 2:
<code>sat.loc[sat["Year"] == 2007].set_index("State")["Math"].idxmax()</code>
After boolean indexing for entries made in 2007, it correctly returns
the state name with the max <code>"Math"</code> score.</p>
<p>Option 3: <code>sat.groupby("Year")["State"].max().loc[2007]</code>
This finds the maximum state name alphabet-wise, not the state with the
highest math score.</p>
<p>Option 4:
<code>(sat.loc[sat["Math"] == sat.loc[sat["Year"] == 2007, "Math"].max()].iloc[0].loc["State"])</code>
This expression looks to match any recorded score that is equal to the
max score in 2007, possibly returning a value outside of 2007.</p>
<p>Option 5:
<code>(sat.groupby("Year").apply(lambda sat: sat[sat["Math"] == sat["Math"].max()]).reset_index(drop=True).groupby("Year")["State"].max().loc[2007])</code>
Option 5 works by isolating rows with the highest score per year, and
then among these, it finds the state for the year 2007.</p>
<p>Option 6:
<code>sat.loc[sat['Year'] == 2007].loc[sat['Math'] == sat['Math'].max()]</code>
Similar to Option 4, this expression finds the maximum math score across
all years and then tries to match it to the year 2007, which may not be
correct.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 71%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.2">Problem 1.2</h3>
<p>In the box, write a <strong>one-line expression</strong> that
evaluates to a DataFrame that is equivalent to the following
relation:</p>
<p><span class="math display">\Pi_{\text{Year, State, Verbal}}
\left(\sigma_{\text{Year } \geq \: 2014 \text{ and Math } \leq \: 600}
\left( \text{sat} \right) \right)</span></p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_2" aria-expanded="true" aria-controls="collapse1_2">
Click to view the solution.
</button>
</h2>
<div id="collapse1_2" class="accordion-collapse collapse"
aria-labelledby="heading1_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong>
<code>sat.loc[(sat['Year'] &gt;= 2014) &amp; (sat['Math'] &lt;= 600), ['Year', 'State', 'Verbal']]</code></p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 85%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.3">Problem 1.3</h3>
<p>The following two lines define two DataFrames, <code>val1</code> and
<code>val2</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>val1 <span class="op">=</span> sat.groupby([<span class="st">&quot;Year&quot;</span>, <span class="st">&quot;State&quot;</span>]).<span class="bu">max</span>().reset_index()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>val2 <span class="op">=</span> sat.groupby([<span class="st">&quot;Year&quot;</span>, <span class="st">&quot;State&quot;</span>, <span class="st">&quot;# Students&quot;</span>]).<span class="bu">min</span>().reset_index()</span></code></pre></div>
<p>Are <code>val1</code> and <code>val2</code> identical? That is, do
they contain the same rows and columns, all in the same order?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Yes</p></li>
<li><p><input type="radio" disabled="" /> No</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_3" aria-expanded="true" aria-controls="collapse1_3">
Click to view the solution.
</button>
</h2>
<div id="collapse1_3" class="accordion-collapse collapse"
aria-labelledby="heading1_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Yes</p>
<p>No pair of <code>"Year"</code> and <code>"State"</code> will be
appear twice in the DataFrame because each combination of
<code>"Year"</code> and <code>"State"</code> are unqiue. Therefore, when
grouping by these columns, each group only contains one unique row - the
row itself. Thus, using the maximum operation on these groups simply
retrieves the original rows.</p>
<p>Likewise, since every combination of <code>"Year"</code>,
<code>"State"</code>, and <code>"# Students"</code> is also unique, the
minimum operation, when applied after grouping, yields the same result:
the original row for each group.</p>
<p>Recall that <code>.groupby</code> function in Pandas automatically
sorts data based on the chosen grouping keys. As a result, the
<code>val1</code> and <code>val2</code> DataFrames, created using these
groupings, contain the same rows and columns, displayed in the same
order.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 67%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.4">Problem 1.4</h3>
<p>The data description stated that there is one row in <code>sat</code>
for most combinations of <code>"Year"</code> (between <code>2005</code>
and <code>2015</code>, inclusive) and <code>"State"</code>. This means
that for most states, there are 11 rows in <code>sat</code> — one for
each year between 2005 and 2015, inclusive.</p>
<p>It turns out that there are 11 rows in <code>sat</code> for all 50
states, except for one state. Fill in the blanks below so that
<code>missing_years</code> evaluates to an <strong>array</strong>,
sorted in any order, containing the years for which that one state does
not appear in `sat.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>state_only <span class="op">=</span> sat.groupby(<span class="st">&quot;State&quot;</span>).<span class="bu">filter</span>(___(a)___)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>merged <span class="op">=</span> sat[<span class="st">&quot;Year&quot;</span>].value_counts().to_frame().merge(</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    state_only, ___(b)___</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>missing_years <span class="op">=</span> ___(c)___.to_numpy()</span></code></pre></div>
<p>What goes in the blanks?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_4" aria-expanded="true" aria-controls="collapse1_4">
Click to view the solution.
</button>
</h2>
<div id="collapse1_4" class="accordion-collapse collapse"
aria-labelledby="heading1_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong></p>
<ul>
<li>a: <code>lambda df: df.shape[0] &lt; 11</code></li>
<li>b: <code>left_index=True, right_on='Year', how='left'</code>
(<code>how='outer'</code> also works)</li>
<li>c: <code>merged[merged['# Students'].isna()]['Year']</code></li>
</ul>
<p><br/></p>
<h4 id="blank-a">Blank A</h4>
<p>The initial step (in the <code>state_only</code> variable) involves
identifying the state that has fewer than 11 records in the dataset.
This is achieved by the lambda function
<code>lambda df: df.shape[0] &lt; 11</code>, leaving us with records
from only the state that has missing data for certain years.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 72%.</p>
<p><br/></p>
<h4 id="blank-b">Blank B</h4>
<p>Next, applying <code>.value_counts()</code> to
<code>sat["Year"]</code> produces a Series that enumerates the total
occurrences of each year from 2005 to 2015. Converting this Series to a
DataFrame with <code>.to_frame()</code>, we then merge it with the
<code>state_only</code> DataFrame. This merging results in a DataFrame
(merged) where the years lacking corresponding entries in
<code>state_only</code> are marked as NaN.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 52%.</p>
<p><br/></p>
<h4 id="blank-c">Blank C</h4>
<p>Finally, the expression
<code>merged[merged['# Students'].isna()]['Year']</code> in
<code>missing_years</code> identifies the specific years that are absent
for the one state in the sat dataset. This is determined by selecting
years in the merged DataFrame where the <code>"# Students"</code> column
has NaN values, indicating missing data for those years.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 71%.</p>
</p></p></p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>In the previous subpart, we established that most states have 11 rows
in <code>sat</code> — one for each year between 2005 and 2015, inclusive
— while there is one state that has fewer than 11 rows, because there
are some years for which that state’s SAT information is not known.</p>
<p>Suppose we’re given a version of <code>sat</code> called
<code>sat_complete</code> that has all of the same information as
<code>sat</code>, but that also has rows for combinations of states and
years in which SAT information is not known. While there are no null
values in the <code>"Year"</code> or <code>"State"</code> columns of
<code>sat_complete</code>, there are null values in the
<code>"# Students"</code>, <code>"Math"</code>, and
<code>"Verbal"</code> columns of <code>sat_complete</code>. An example
of what <code>sat_complete</code> may look like is given below.</p>
<center><img src='../assets/images/wi23-final/sat_tail.png' width=30%></center>
<center><img src='../assets/images/wi23-final/sat_other_tail.png' width=30%></center>
<p><em>Note that in the above example, <code>sat</code> simply wouldn’t
have rows for West Virginia in 2005 and 2006, meaning it would have 2
fewer rows than the corresponding <code>sat_complete</code>.</em></p>
<p><br></p>
<h3 id="problem-1.5">Problem 1.5</h3>
<p>Given just the information in <code>sat_complete</code> — that is,
without including any information learned in part (d) — what is the most
likely missingness mechanism of the <code>"# Students"</code> column in
<code>sat_complete</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Not missing at random</p></li>
<li><p><input type="radio" disabled="" /> Missing at random</p></li>
<li><p><input type="radio" disabled="" /> Missing completely at random</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_5" aria-expanded="true" aria-controls="collapse1_5">
Click to view the solution.
</button>
</h2>
<div id="collapse1_5" class="accordion-collapse collapse"
aria-labelledby="heading1_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> Not missing at random</p>
<p>The fact that there are null values specifically in the cases where
SAT data is not available suggests that the missingness of the
<code>"# Students"</code> column is systematic. It’s not occurring
randomly across the dataset, but rather in specific instances where SAT
data wasn’t recorded or available.</p>
<p>This could mean that the absence of student numbers is linked to
specific reasons why the data was not recorded or collected, such as
certain states not participating in SAT testing in specific years, or
administrative decisions that led to non-recording of data.</p>
<p>The nature of this missingness suggests that it’s not random or
solely dependent on observed data in other columns, but rather it’s
related to the inherent nature of the <code>"# Students"</code> data
itself.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 54%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.6">Problem 1.6</h3>
<p>Given just the information in <code>sat_complete</code> — that is,
without including any information learned in part (d) — what is the most
likely missingness mechanism of the <code>"Math"</code> column in
<code>sat_complete</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Not missing at random</p></li>
<li><p><input type="radio" disabled="" /> Missing at random</p></li>
<li><p><input type="radio" disabled="" /> Missing completely at random</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_6">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_6" aria-expanded="true" aria-controls="collapse1_6">
Click to view the solution.
</button>
</h2>
<div id="collapse1_6" class="accordion-collapse collapse"
aria-labelledby="heading1_6" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Missing at random</p>
<p>If a state has reported the number of students taking the SAT, it
implies that data collection and reporting were carried out. The
administrative decision to report SAT scores (including
<code>"Math"</code> scores) may be reflected in the
<code>"# Students"</code> column. Conversely, if the
<code>"# Students"</code> column is empty or null for a certain state
and year, it might indicate an administrative decision not to
participate or report data for that period. This decision impacts the
availability of <code>"Math"</code> scores.</p>
<p>In this context, the missing values in <code>"Math"</code> scores are
linked to observable conditions or patterns in the dataset (like
specific years, states, or availability of other related data).</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 75%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.7">Problem 1.7</h3>
<p>Suppose we perform a permutation test to assess whether the
missingness of column <span class="math inline">Y</span> depends on
column <span class="math inline">X</span>.</p>
<p>Suppose we observe a statistically significant result (that is, the
<span class="math inline">p</span>-value of our test is less than 0.05).
True or False: It is still possible for column <span
class="math inline">Y</span> to be not missing at random.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_7">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_7" aria-expanded="true" aria-controls="collapse1_7">
Click to view the solution.
</button>
</h2>
<div id="collapse1_7" class="accordion-collapse collapse"
aria-labelledby="heading1_7" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> True</p>
<p>The observation of a statistically significant result (a p-value less
than 0.05) in a permutation test suggests there is some association or
dependency between the missingness in Y and the values in X. However,
this result does not exclude the possibility that the missingness in Y
is also influenced by factors not captured in column X, or by the values
in Y itself.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 71%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-1.8">Problem 1.8</h3>
<p>Suppose we do not observe a statistically significant result (that
is, the <span class="math inline">p</span>-value of our test is greater
than 0.05). True or False: It is still possible for column <span
class="math inline">Y</span> to be missing at random dependent on column
<span class="math inline">X</span>.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading1_8">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse1_8" aria-expanded="true" aria-controls="collapse1_8">
Click to view the solution.
</button>
</h2>
<div id="collapse1_8" class="accordion-collapse collapse"
aria-labelledby="heading1_8" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> True</p>
<p>Not observing a statistically significant result (a p-value greater
than 0.05) in a permutation test means that the test did not find strong
evidence of a dependency between X and the missingness in Y. However,
this does not definitively prove that such a dependency does not exist.
In statistical testing, a lack of significant findings is not the same
as evidence of no effect or no association.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 78%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-2">Problem 2</h2>
<p>The following DataFrame contains the mean, median, and standard
deviation of the number of students per year who took the SAT in New
York and Texas between 2005 and 2015.</p>
<center><img src='../assets/images/wi23-final/nyt.png' width=35%></center>
<p><br></p>
<h3 id="problem-2.1">Problem 2.1</h3>
<p>Which of the following expressions creates the above DataFrame
correctly and in the most efficient possible way (in terms of time and
space complexity)?</p>
<p><em>Note: The only difference between the options is the positioning
of <code>"# Students"</code>.</em></p>
<p>Option 1:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(sat.loc[sat[<span class="st">&quot;State&quot;</span>].isin([<span class="st">&quot;New York&quot;</span>, <span class="st">&quot;Texas&quot;</span>])]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;# Students&quot;</span>].groupby(<span class="st">&quot;State&quot;</span>).agg([<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;std&quot;</span>]))</span></code></pre></div>
<p>Option 2:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(sat.loc[sat[<span class="st">&quot;State&quot;</span>].isin([<span class="st">&quot;New York&quot;</span>, <span class="st">&quot;Texas&quot;</span>])]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>.groupby(<span class="st">&quot;State&quot;</span>)[<span class="st">&quot;# Students&quot;</span>].agg([<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;std&quot;</span>]))</span></code></pre></div>
<p>Option 3:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(sat.loc[sat[<span class="st">&quot;State&quot;</span>].isin([<span class="st">&quot;New York&quot;</span>, <span class="st">&quot;Texas&quot;</span>])]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>.groupby(<span class="st">&quot;State&quot;</span>).agg([<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;std&quot;</span>])[<span class="st">&quot;# Students&quot;</span>])</span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Option 1</p></li>
<li><p><input type="radio" disabled="" /> Option 2</p></li>
<li><p><input type="radio" disabled="" /> Option 3</p></li>
<li><p><input type="radio" disabled="" /> Multiple options are equally correct and efficient</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_1" aria-expanded="true" aria-controls="collapse2_1">
Click to view the solution.
</button>
</h2>
<div id="collapse2_1" class="accordion-collapse collapse"
aria-labelledby="heading2_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 2</p>
<ul>
<li>Option 1 is incorrect because it attempts to select the
<code>"# Students"</code> column before grouping by
<code>"State"</code>, which is not possible.</li>
<li>Option 2 filters the DataFrame, groups by <code>"State"</code>, and
then performs aggregation only on the <code>"# Students"</code> column,
making it efficient.</li>
<li>Option 3 does the aggregations for all columns first and then
selects the <code>"# Students"</code> column, which is correct but less
efficient because it computes aggregations for potentially many columns
(like <code>"Math"</code>) that are not needed.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 75%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>Suppose we want to run a statistical test to assess whether the
distributions of the number of students between 2005 and 2015 in New
York and Texas are significantly different.</p>
<p><br></p>
<h3 id="problem-2.2">Problem 2.2</h3>
<p>What type of test is being proposed above?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Hypothesis test</p></li>
<li><p><input type="radio" disabled="" /> Permutation test</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_2" aria-expanded="true" aria-controls="collapse2_2">
Click to view the solution.
</button>
</h2>
<div id="collapse2_2" class="accordion-collapse collapse"
aria-labelledby="heading2_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Permutation test</p>
<p>Here, we’re comparing whether two sample distributions –
specifically, (1) the distribution of the number of students per year
from 2005-2015 for New York and (2) the distribution of the number of
students per year from 2005-2015 for Texas – are significantly
different. This is precisely what a permutation test is used for. For
the purposes of this test, we have 22 relevant rows of data – 11 for New
York and 11 for Texas – and 2 columns, <code>"State"</code> and
<code>"# Students"</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 90%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-2.3">Problem 2.3</h3>
<p>Given the information in the above DataFrame, which test statistic is
<strong>most likely</strong> to yield a significant difference?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <span class="math inline">\text{mean number of students in Texas } -
\text{ mean number of students in New York}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\big|\text{mean number of students in Texas
} - \text{ mean number of students in New York}\big|</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\big|\text{median number of students in
Texas } - \text{ median number of students in New York}\big|</span></p></li>
<li><p><input type="radio" disabled="" /> The Kolmogorov-Smirnov statistic</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_3" aria-expanded="true" aria-controls="collapse2_3">
Click to view the solution.
</button>
</h2>
<div id="collapse2_3" class="accordion-collapse collapse"
aria-labelledby="heading2_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> The Kolmogorov-Smirnov statistic</p>
<p>Here, the means and medians of the two samples are similar, so their
observed difference in means and observed difference in medians are both
small. This means that a permutation test using either one of those as a
test statistic will likely fail to yield a significant difference.
However, the standard deviations of both distributions are quite
different, which means the shapes of the distributions are quite
different. The Kolmogorov-Smirnov statistic measures the distance
between two distributions by considering their entire shape, and since
these distributions have very different shapes, they will likely have a
larger Kolmogorov-Smirnov statistic than expected under the null.</p>
<!-- The difference in means an median only focuses on the central tendency and is unable to consider the full distribution of the data. The Kolmogorov-Smirnov statistic is most likely to yield a significant difference if there are any differences in the distributions beyond just the central tendency. It is more comprehensive as it evaluates differences across the entire range of the distributions, making it a robust choice for comparing the two states' SAT student distributions. -->
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 78%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>Now, suppose we’re interested in comparing the verbal score
distribution of students who took the SAT in New York in 2015 to the
verbal score distribution of all students who took the SAT in 2015.</p>
<p>The DataFrame <code>scores_2015</code>, shown in its entirety below,
contains the verbal section score distributions of students in New York
in 2015 and for all students in 2015.</p>
<center><img src='../assets/images/wi23-final/ny_vs_all.png' width=25%></center>
<p><br></p>
<h3 id="problem-2.4">Problem 2.4</h3>
<p>What type of test is being proposed above?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Hypothesis test</p></li>
<li><p><input type="radio" disabled="" /> Permutation test</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_4" aria-expanded="true" aria-controls="collapse2_4">
Click to view the solution.
</button>
</h2>
<div id="collapse2_4" class="accordion-collapse collapse"
aria-labelledby="heading2_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Hypothesis test</p>
<p>One way to think about “standard” hypothesis tests is that they test
whether a given sample – in this case, the verbal score distribution of
New York students in 2015 – looks like it was drawn from a given
population – here, the verbal score distribution of all students in
2015. That’s what’s happening here.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 87%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-2.5">Problem 2.5</h3>
<p>Suppose <span class="math inline">\vec{a} = \begin{bmatrix} a_1 &amp;
a_2 &amp; ... &amp; a_n \end{bmatrix}^T</span> and <span
class="math inline">\vec{b} = \begin{bmatrix} b_1 &amp; b_2 &amp; ...
&amp; b_n \end{bmatrix}^T</span> are both vectors containing proportions
that add to 1 (e.g. <span class="math inline">\vec{a}</span> could be
the <code>"New York"</code> column above and <span
class="math inline">\vec{b}</span> could be the
<code>"All States"</code> column above). As we’ve seen before, the TVD
is defined as follows:</p>
<p><span class="math inline">\text{TVD}(\vec{a}, \vec{b}) = \frac{1}{2}
\sum_{i = 1}^n \left| a_i - b_i \right|</span></p>
<p>The TVD is not the only metric that can quantify the distance between
two categorical distributions. Here are three other possible distance
metrics:</p>
<ul>
<li><p><span class="math inline">\text{dis1}(\vec{a}, \vec{b}) = \vec{a}
\cdot \vec{b} = a_1b_1 + a_2b_2 + ... + a_nb_n</span></p></li>
<li><p><span class="math inline">\text{dis2}(\vec{a}, \vec{b}) =
\frac{\vec{a} \cdot \vec{b}}{|\vec{a} | | \vec{b} |} = \frac{a_1b_1 +
a_2b_2 + ... + a_nb_n}{\sqrt{a_1^2 + a_2^2 + ... + a_n^2} \sqrt{b_1^2 +
b_2^2 + ... + b_n^2}}</span></p></li>
<li><p><span class="math inline">\text{dis3}(\vec{a}, \vec{b}) = 1 -
\frac{\vec{a} \cdot \vec{b}}{|\vec{a} | | \vec{b} |}</span></p></li>
</ul>
<p>Of the above three possible distance metrics, only one of them has
the same range as the TVD (i.e. the same minimum possible value and the
same maximum possible value) <strong>and</strong> has the property that
smaller values correspond to more similar vectors. Which distance metric
is it?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <span class="math inline">\text{dis1}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\text{dis2}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\text{dis3}</span></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading2_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse2_5" aria-expanded="true" aria-controls="collapse2_5">
Click to view the solution.
</button>
</h2>
<div id="collapse2_5" class="accordion-collapse collapse"
aria-labelledby="heading2_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <span class="math inline">\text{dis3}</span></p>
<p>Let’s look at the options carefully:</p>
<ul>
<li><span class="math inline">\text{dis1}</span> does not have the
property that smaller values correspond to more similar vectors.
Consider <span class="math inline">\vec{a} = [1, 0], \vec{b} = [0, 1],
\vec{c} = [1, 0]</span>. Here, <span class="math inline">\text{dis1}(\vec{a}, \vec{b}) = 1 \cdot 0 + 0 \cdot
1 = 0</span> and <span class="math inline">\text{dis1}(\vec{a}, \vec{c})
= 1 \cdot 1 + 0 \cdot 0 = 1</span>. <span class="math inline">\vec{a}</span> and <span class="math inline">\vec{c}</span> are the exact same vector, but they
have a larger <span class="math inline">\text{dis1}</span> value than
<span class="math inline">\vec{a}</span> and <span class="math inline">\vec{b}</span>, which are very different vectors.
<span class="math inline">\text{dis1}</span> has the property that
larger values correspond to more similar vectors, which is what we’re
looking for.</li>
<li><span class="math inline">\text{dis2}</span> behaves the same way
that <span class="math inline">\text{dis1}</span> does, in that larger
values correspond to more similar vectors. Note that the numerator of
<span class="math inline">\text{dis2}</span> is just <span class="math inline">\text{dis1}</span>.</li>
<li>By process of elimination, the answer must be <span class="math inline">\text{dis3}</span>. But, for those who are curious,
why does <span class="math inline">\text{dis3}</span> work? Here’s why:
<ul>
<li>Remember from Math 18 that if <span class="math inline">\vec{a}</span> and <span class="math inline">\vec{b}</span> are two vectors, then their dot
product can be expressed as <span class="math inline">\vec{a} \cdot
\vec{b} = | \vec{a} | | \vec{b} | \cos \theta</span>, where <span class="math inline">\theta</span> is the angle between the two
vectors.</li>
<li>If all of the elements in <span class="math inline">\vec{a}</span>
and <span class="math inline">\vec{b}</span> are non-negative, then the
angle <span class="math inline">\theta</span> between <span class="math inline">\vec{a}</span> and <span class="math inline">\vec{b}</span> must be between 0 and 90 degrees,
which means <span class="math inline">\cos \theta</span> must be between
1 (when <span class="math inline">\theta</span> is 0) and 0 (when <span class="math inline">\theta</span> is 90).</li>
<li>Rearranging the dot product, we have that <span class="math inline">\cos \theta = \frac{\vec{a} \cdot \vec{b}}{|\vec{a}
| | \vec{b} |}</span>. When <span class="math inline">\vec{a}</span> and
<span class="math inline">\vec{b}</span> point in the same direction –
that is, when they are as similar as possible – <span class="math inline">\cos \theta</span> is 1, and when they are as
different as possible – that is, when they are orthogonal – <span class="math inline">\cos \theta</span> is 0. This is the exact opposite
of the behavior we want in a distance metric, where we want smaller
values to correspond to more similar vectors, not larger values. Note
that <span class="math inline">\cos \theta</span> is the same as <span class="math inline">\text{dis2}</span>.</li>
<li>By computing <span class="math inline">\text{dis3}(\vec{a}, \vec{b})
= 1 - \cos \theta = 1 - \frac{\vec{a} \cdot \vec{b}}{|\vec{a} | |
\vec{b} |}</span>, we reverse the behavior of <span class="math inline">\cos \theta</span>: when $ and <span class="math inline">\vec{b}</span> point in the same direction, <span class="math inline">\text{dis3}(\vec{a}, \vec{b}) = 0</span>, and when
they are very different, <span class="math inline">\text{dis3}(\vec{a},
\vec{b}) = 1</span>. Now, <span class="math inline">\text{dis3}(\vec{a},
\vec{b})</span> behaves the same way as the TVD, in that a value of 0
means the vectors are identical and a value of 1 means the vectors are
very different!</li>
</ul></li>
</ul>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 75%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-3">Problem 3</h2>
<p>The function <code>state_perm</code> is attempting to implement a
test of the null hypothesis that the distributions of mean math section
scores between 2005 and 2015 for two states are drawn from the same
population distribution.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> state_perm(states):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(states) <span class="op">!=</span> <span class="dv">2</span>:</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Expected 2 elements, got </span><span class="sc">{</span><span class="bu">len</span>(states)<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calc_test_stat(df):</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> df.groupby(<span class="st">&quot;State&quot;</span>)[<span class="st">&quot;Math&quot;</span>].mean().<span class="bu">abs</span>().diff().iloc[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    states <span class="op">=</span> sat.loc[sat[<span class="st">&quot;State&quot;</span>].isin(states), [<span class="st">&quot;State&quot;</span>, <span class="st">&quot;Math&quot;</span>]]</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    test_stats <span class="op">=</span> []</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10000</span>):</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        states[<span class="st">&quot;State&quot;</span>] <span class="op">=</span> np.random.permutation(states[<span class="st">&quot;State&quot;</span>])</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        test_stat <span class="op">=</span> calc_test_stat(states)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        test_stats.append(test_stat)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    obs <span class="op">=</span> calc_test_stat(states)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (np.array(test_stats) <span class="op">&gt;=</span> obs).mean()</span></code></pre></div>
<p>Suppose we call <code>state_perm(["California", "Washington"])</code>
and see <code>0.514</code>.</p>
<p><br></p>
<h3 id="problem-3.1">Problem 3.1</h3>
<p>What test statistic is being used in the above call to
<code>state_perm</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <span class="math inline">\text{mean Washington score } - \text{mean
California score}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\text{mean California score } - \text{mean
Washington score}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\big|\text{mean Washington score } -
\text{mean California score} \big|</span></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_1" aria-expanded="true" aria-controls="collapse3_1">
Click to view the solution.
</button>
</h2>
<div id="collapse3_1" class="accordion-collapse collapse"
aria-labelledby="heading3_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 1</p>
<p>Lets take a deeper look at <code>calc_test_stat(df)</code>.</p>
<p>The function first calculates the mean math scores in each state.
Although the <code>.abs()</code> method is applied, it is redundant at
this stage since no differences have been computed yet. The key
operation is <code>.diff()</code>, which computes the difference between
the mean scores of the two states. Since groupby sorts states
alphabetically, it subtracts the mean score of California (appearing
first) from Washington (appearing second). The final expression
<code>df.groupby("State")["Math"].mean().abs().diff().iloc[-1]</code>
thus represents mean Washington score − mean California score.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 27%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-3.2">Problem 3.2</h3>
<p>There is exactly one issue with the implementation of
<code>state_perm</code>. In <strong>exactly one sentence</strong>,
identify the issue and state how you would fix it.</p>
<p><em>Hint: The issue is <strong>not</strong> with the implementation
of the function <code>calc_test_stat</code>.</em></p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading3_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse3_2" aria-expanded="true" aria-controls="collapse3_2">
Click to view the solution.
</button>
</h2>
<div id="collapse3_2" class="accordion-collapse collapse"
aria-labelledby="heading3_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Since we are permuting in-place on the
<code>states</code> DataFrame, we must calculate the observed test
statistic before we permute.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 81%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-4">Problem 4</h2>
<p>To prepare for the verbal component of the SAT, Nicole decides to
read research papers on data science. While reading these papers, she
notices that there are many citations interspersed that refer to other
research papers, and she’d like to read the cited papers as well.</p>
<p>In the papers that Nicole is reading, citations are formatted in the
<em>verbose numeric</em> style. An excerpt from one such paper is stored
in the string <code>s</code> below.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&#39;&#39;&#39;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="st">In DSC 10 [3], you learned about babypandas, a strict subset</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="st">of pandas [15][4]. It was designed [5] to provide programming</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="st">beginners [3][91] just enough syntax to be able to perform</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="st">meaningful tabular data analysis [8] without getting lost in</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="st">100s of details.</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;&#39;&#39;</span></span></code></pre></div>
<p>We decide to help Nicole extract citation numbers from papers.
Consider the following four extracted lists.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>list1 <span class="op">=</span> [<span class="st">&#39;10&#39;</span>, <span class="st">&#39;100&#39;</span>]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>list2 <span class="op">=</span> [<span class="st">&#39;3&#39;</span>, <span class="st">&#39;15&#39;</span>, <span class="st">&#39;4&#39;</span>, <span class="st">&#39;5&#39;</span>, <span class="st">&#39;3&#39;</span>, <span class="st">&#39;91&#39;</span>, <span class="st">&#39;8&#39;</span>]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>list3 <span class="op">=</span> [<span class="st">&#39;10&#39;</span>, <span class="st">&#39;3&#39;</span>, <span class="st">&#39;15&#39;</span>, <span class="st">&#39;4&#39;</span>, <span class="st">&#39;5&#39;</span>, <span class="st">&#39;3&#39;</span>, <span class="st">&#39;91&#39;</span>, <span class="st">&#39;8&#39;</span>, <span class="st">&#39;100&#39;</span>]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>list4 <span class="op">=</span> [<span class="st">&#39;[3]&#39;</span>, <span class="st">&#39;[15]&#39;</span>, <span class="st">&#39;[4]&#39;</span>, <span class="st">&#39;[5]&#39;</span>, <span class="st">&#39;[3]&#39;</span>, <span class="st">&#39;[91]&#39;</span>, <span class="st">&#39;[8]&#39;</span>]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>list5 <span class="op">=</span> [<span class="st">&#39;1&#39;</span>, <span class="st">&#39;0&#39;</span>, <span class="st">&#39;3&#39;</span>, <span class="st">&#39;1&#39;</span>, <span class="st">&#39;5&#39;</span>, <span class="st">&#39;4&#39;</span>, <span class="st">&#39;5&#39;</span>, <span class="st">&#39;3&#39;</span>,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>         <span class="st">&#39;9&#39;</span>, <span class="st">&#39;1&#39;</span>, <span class="st">&#39;8&#39;</span>, <span class="st">&#39;1&#39;</span>, <span class="st">&#39;0&#39;</span>, <span class="st">&#39;0&#39;</span>]</span></code></pre></div>
<p>For each expression below, select the list it evaluates to, or select
“None of the above.”</p>
<p><br></p>
<h3 id="problem-4.1">Problem 4.1</h3>
<p><code>re.findall(r'\d+', s)</code></p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>list1</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list2</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list3</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list4</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list5</code></p></li>
<li><p><input type="radio" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_1" aria-expanded="true" aria-controls="collapse4_1">
Click to view the solution.
</button>
</h2>
<div id="collapse4_1" class="accordion-collapse collapse"
aria-labelledby="heading4_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>list3</code></p>
<p>This regex pattern <code>\d+</code> matches one or more digits
anywhere in the string. It doesn’t concern itself with the context of
the digits, whether they are inside brackets or not. As a result, it
extracts all sequences of digits in s, including <code>'10'</code>,
<code>'3'</code>, <code>'15'</code>, <code>'4'</code>, <code>'5'</code>,
<code>'3'</code>, <code>'91'</code>, <code>'8'</code>, and
<code>'100'</code>, which together form <code>list3</code>. This is
because <code>\d+</code> greedily matches all contiguous digits,
capturing both the citation numbers and any other numbers present in the
text.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 81%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.2">Problem 4.2</h3>
<p><code>re.findall(r'[\d+]', s)</code></p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>list1</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list2</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list3</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list4</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list5</code></p></li>
<li><p><input type="radio" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_2" aria-expanded="true" aria-controls="collapse4_2">
Click to view the solution.
</button>
</h2>
<div id="collapse4_2" class="accordion-collapse collapse"
aria-labelledby="heading4_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>list5</code></p>
<p>This pattern <code>[\d+]</code> is slightly misleading because the
square brackets are used to define a character class, and the plus sign
inside is treated as a literal character, not as a quantifier. However,
since there are no plus signs in <code>s</code>, this detail does not
affect the outcome. The character class <code>\d</code> matches any
digit, so this pattern effectively matches individual digits throughout
the string, resulting in <code>list5</code>. This list contains every
single digit found in <code>s</code>, separated as individual string
elements.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 31%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.3">Problem 4.3</h3>
<p><code>re.findall(r'\[(\d+)\]', s)</code></p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>list1</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list2</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list3</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list4</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list5</code></p></li>
<li><p><input type="radio" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_3" aria-expanded="true" aria-controls="collapse4_3">
Click to view the solution.
</button>
</h2>
<div id="collapse4_3" class="accordion-collapse collapse"
aria-labelledby="heading4_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>list2</code></p>
<p>This pattern is specifically designed to match digits that are
enclosed in square brackets. The <code>\[(\d+)\]</code> pattern looks
for a sequence of one or more digits <code>\d+</code> inside square
brackets <code>[]</code>. The parentheses capture the digits as a group,
excluding the brackets from the result. Therefore, it extracts just the
citation numbers as they appear in <code>s</code>, matching
<code>list2</code> exactly. This method is precise for extracting
citation numbers from a text formatted in the verbose numeric style.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 80%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-4.4">Problem 4.4</h3>
<p><code>re.findall(r'(\[\d+\])', s)</code></p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>list1</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list2</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list3</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list4</code></p></li>
<li><p><input type="radio" disabled="" /> <code>list5</code></p></li>
<li><p><input type="radio" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading4_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse4_4" aria-expanded="true" aria-controls="collapse4_4">
Click to view the solution.
</button>
</h2>
<div id="collapse4_4" class="accordion-collapse collapse"
aria-labelledby="heading4_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>list4</code></p>
<p>Similar to the previous explanation but with a key difference: the
entire pattern of digits within square brackets is captured, including
the brackets themselves. The pattern <code>\[\d+\]</code> specifically
searches for sequences of digits surrounded by square brackets, and the
parentheses around the entire pattern ensure that the match includes the
brackets. This results in <code>list4</code>, which contains all the
citation markers found in <code>s</code>, preserving the brackets to
clearly denote them as citations.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 91%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-5">Problem 5</h2>
<p>After taking the SAT, Nicole wants to check the College Board’s
website to see her score. However, the College Board recently updated
their website to use non-standard HTML tags and Nicole’s browser can’t
render it correctly. As such, she resorts to making a GET request to the
site with her scores on it to get back the source HTML and tries to
parse it with BeautifulSoup.</p>
<p>Suppose <code>soup</code> is a BeautifulSoup object instantiated
using the following HTML document.</p>
<pre><code>&lt;college&gt;Your score is ready!&lt;/college&gt;

&lt;sat verbal=&quot;ready&quot; math=&quot;ready&quot;&gt;
  Your percentiles are as follows:
  &lt;scorelist listtype=&quot;percentiles&quot;&gt;
    &lt;scorerow kind=&quot;verbal&quot; subkind=&quot;per&quot;&gt;
      Verbal: &lt;scorenum&gt;84&lt;/scorenum&gt;
    &lt;/scorerow&gt;
    &lt;scorerow kind=&quot;math&quot; subkind=&quot;per&quot;&gt;
      Math: &lt;scorenum&gt;99&lt;/scorenum&gt;
    &lt;/scorerow&gt;
  &lt;/scorelist&gt;
  And your actual scores are as follows:
  &lt;scorelist listtype=&quot;scores&quot;&gt;
    &lt;scorerow kind=&quot;verbal&quot;&gt; Verbal: &lt;scorenum&gt;680&lt;/scorenum&gt; &lt;/scorerow&gt;
    &lt;scorerow kind=&quot;math&quot;&gt; Math: &lt;scorenum&gt;800&lt;/scorenum&gt; &lt;/scorerow&gt;
  &lt;/scorelist&gt;
&lt;/sat&gt;</code></pre>
<p><br></p>
<h3 id="problem-5.1">Problem 5.1</h3>
<p>Which of the following expressions evaluate to <code>"verbal"</code>?
Select all that apply.</p>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" /> <code>soup.find("scorerow").get("kind")</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>soup.find("sat").get("ready")</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>soup.find("scorerow").text.split(":")[0].lower()</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>[s.get("kind") for s in soup.find_all("scorerow")][-2]</code></p></li>
<li><p><input type="checkbox" disabled="" /> <code>soup.find("scorelist", attrs={"listtype":"scores"}).get("kind")</code></p></li>
<li><p><input type="checkbox" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_1" aria-expanded="true" aria-controls="collapse5_1">
Click to view the solution.
</button>
</h2>
<div id="collapse5_1" class="accordion-collapse collapse"
aria-labelledby="heading5_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 1, Option 3, Option 4</p>
<p>Correct options:</p>
<ul>
<li>Option 1 finds the first <code>&lt;scorerow&gt;</code> element and
retrieves its <code>"kind"</code> attribute, which is
<code>"verbal"</code> for the first <code>&lt;scorerow&gt;</code>
encountered in the HTML document.</li>
<li>Option 2 finds the first <code>&lt;scorerow&gt;</code> tag,
retrieves its text <code>("Verbal: 84")</code>, splits this text by “:”,
and takes the first element of the resulting list
<code>("Verbal")</code>, converting it to lowercase to match
<code>"verbal"</code>.</li>
<li>Option 3 creates a list of <code>"kind"</code> attributes for all
<code>&lt;scorerow&gt;</code> elements. The second to last (-2) element
in this list corresponds to the <code>"kind"</code> attribute of the
first <code>&lt;scorerow&gt;</code> in the second
<code>&lt;scorelist&gt;</code> tag, which is also
<code>"verbal"</code>.</li>
</ul>
<p>Incorrect options:</p>
<ul>
<li>Option 2 attempts to get an attribute ready from the
<code>&lt;sat&gt;</code> tag, which does not exist as an attribute.</li>
<li>Option 5 tries to retrieve a <code>"kind"</code> attribute from a
<code>&lt;scorelist&gt;</code> tag, but <code>&lt;scorelist&gt;</code>
does not have a <code>"kind"</code> attribute.</li>
</ul>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 90%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-5.2">Problem 5.2</h3>
<p>Consider the following function.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> summer(tree):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(tree, <span class="bu">list</span>):</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> subtree <span class="kw">in</span> tree:</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> s <span class="kw">in</span> subtree.find_all(<span class="st">&quot;scorenum&quot;</span>):</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>                total <span class="op">+=</span> <span class="bu">int</span>(s.text)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">sum</span>([<span class="bu">int</span>(s.text) <span class="cf">for</span> s <span class="kw">in</span> tree.find_all(<span class="st">&quot;scorenum&quot;</span>)])</span></code></pre></div>
<p>For each of the following values, fill in the blanks to assign
<code>tree</code> such that <code>summer(tree)</code> evaluates to the
desired value. The first example has been done for you.</p>
<ul>
<li>Desired value: <code>84</code></li>
</ul>
<div class="sourceCode" id="cb17"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> soup.find(<span class="st">&quot;scorerow&quot;</span>)</span></code></pre></div>
<ul>
<li>Desired value: <code>183</code></li>
</ul>
<div class="sourceCode" id="cb18"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> soup.find(__a__)</span></code></pre></div>
<ul>
<li>Desired value: <code>1480</code></li>
</ul>
<div class="sourceCode" id="cb19"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> soup.find(__b__)</span></code></pre></div>
<ul>
<li>Desired value: <code>899</code></li>
</ul>
<div class="sourceCode" id="cb20"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    tree <span class="op">=</span> soup.find_all(__c__)</span></code></pre></div>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading5_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse5_2" aria-expanded="true" aria-controls="collapse5_2">
Click to view the solution.
</button>
</h2>
<div id="collapse5_2" class="accordion-collapse collapse"
aria-labelledby="heading5_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> a: <code>"scorelist"</code>, b:
<code>"scorelist", attrs={"listtype":"scores"}</code>, c:
<code>"scorerow", attrs={"kind":"math"}</code></p>
<p><code>soup.find("scorelist")</code> selects the first
<code>&lt;scorelist&gt;</code> tag, which includes both verbal and math
percentiles <code>(84 and 99)</code>. The function
<code>summer(tree)</code> sums these values to get <code>183</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 92%.</p>
<p>This selects the <code>&lt;scorelist&gt;</code> tag with
<code>listtype="scores"</code>, which contains the actual scores of
verbal <code>(680)</code> and math <code>(800)</code>. The function sums
these to get <code>1480</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 92%.</p>
<p>This selects all <code>&lt;scorerow&gt;</code>elements with
<code>kind="math"</code>, capturing both the percentile
<code>(99)</code> and the actual score <code>(800)</code>. Since tree is
now a list, <code>summer(tree)</code> iterates through each
<code>&lt;scorerow&gt;</code> in the list, summing their
<code>&lt;scorenum&gt;</code> values to reach <code>899</code>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 91%.</p>
</p></p></p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-6">Problem 6</h2>
<p>Consider the following list of tokens.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>tokens <span class="op">=</span> [<span class="st">&quot;is&quot;</span>, <span class="st">&quot;the&quot;</span>, <span class="st">&quot;college&quot;</span>, <span class="st">&quot;board&quot;</span>, <span class="st">&quot;the&quot;</span>, <span class="st">&quot;board&quot;</span>, <span class="st">&quot;of&quot;</span>, <span class="st">&quot;college&quot;</span>]</span></code></pre></div>
<p><br></p>
<h3 id="problem-6.1">Problem 6.1</h3>
<p>Recall, a uniform language model is one in which each
<strong>unique</strong> token has the same chance of being sampled.
Suppose we instantiate a uniform language model on <code>tokens</code>.
The probability of the sentence “the college board is” — that is, <span
class="math inline">P(\text{the college board is})</span> — is of the
form <span class="math inline">\frac{1}{a^b}</span>, where <span
class="math inline">a</span> and <span class="math inline">b</span> are
both positive integers.</p>
<p>What are <span class="math inline">a</span> and <span
class="math inline">b</span>?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_1" aria-expanded="true" aria-controls="collapse6_1">
Click to view the solution.
</button>
</h2>
<div id="collapse6_1" class="accordion-collapse collapse"
aria-labelledby="heading6_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> a = 5, b = 4</p>
<p>In a uniform language model, each unique token has the same chance of
being sampled. Given the list of tokens, there are 5 unique tokens:
[“is”, “the”, “college”, “board”, “of”]. The probability of sampling any
one token is <span class="math inline">\frac{1}{5}</span>. For a
sentence of 4 tokens (“the college board is”), the probability is <span class="math inline">\frac{1}{5^4}</span> because each token is
independently sampled. Thus, <span class="math inline">a = 5</span> and
<span class="math inline">b = 4</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 70%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.2">Problem 6.2</h3>
<p>Recall, a unigram language model is one in which the chance that a
token is sampled is equal to its observed frequency in the list of
tokens. Suppose we instantiate a unigram language model on
<code>tokens</code>. The probability <span
class="math inline">P(\text{the college board is})</span> is of the form
<span class="math inline">\frac{1}{c^d}</span>, where <span
class="math inline">c</span> and <span class="math inline">d</span> are
both positive integers.</p>
<p>What are <span class="math inline">c</span> and <span
class="math inline">d</span>?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_2" aria-expanded="true" aria-controls="collapse6_2">
Click to view the solution.
</button>
</h2>
<div id="collapse6_2" class="accordion-collapse collapse"
aria-labelledby="heading6_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> (c, d) = (2, 9) or (8, 3)</p>
<p>In a unigram language model, the probability of sampling a token is
proportional to its frequency in the token list. The frequencies are:
“is” = 1, “the” = 2, “college” = 2, “board” = 2, “of” = 1. The sentence
“the college board is” has probabilities <span class="math inline">\frac{2}{8}</span>, <span class="math inline">\frac{2}{8}</span>, <span class="math inline">\frac{2}{8}</span>, <span class="math inline">\frac{1}{8}</span> for each word respectively, when
considering the total number of tokens (8). The combined probability is
<span class="math inline">\frac{2}{8} \cdot \frac{2}{8} \cdot
\frac{2}{8} \cdot \frac{1}{8} = \frac{8}{512} = \frac{1}{2^9}</span> or,
simplifying, <span class="math inline">\frac{1}{8^3}</span> since <span class="math inline">512 = 8^3</span>. Therefore, <span class="math inline">c = 2</span> and <span class="math inline">d =
9</span> or <span class="math inline">c = 8</span> and <span class="math inline">d = 3</span>, depending on how you represent the
fraction.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 68%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>For the remainder of this question, consider the following five
sentences.</p>
<ul>
<li><pre><code>&quot;of the college board the&quot;</code></pre></li>
<li><pre><code>&quot;the board the board the&quot;</code></pre></li>
<li><pre><code>&quot;board the college board of&quot;</code></pre></li>
<li><pre><code>&quot;the college board of college&quot;</code></pre></li>
<li><pre><code>&quot;board the college board is&quot;</code></pre></li>
</ul>
<p><br></p>
<h3 id="problem-6.3">Problem 6.3</h3>
<p>Recall, a bigram language model is an <span
class="math inline">N</span>-gram model with <span
class="math inline">N=2</span>. Suppose we instantiate a bigram language
model on <code>tokens</code>. Which of the following sentences of length
5 is the <strong>most</strong> likely to be sampled?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Sentence 1</p></li>
<li><p><input type="radio" disabled="" /> Sentence 2</p></li>
<li><p><input type="radio" disabled="" /> Sentence 3</p></li>
<li><p><input type="radio" disabled="" /> Sentence 4</p></li>
<li><p><input type="radio" disabled="" /> Sentence 5</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_3" aria-expanded="true" aria-controls="collapse6_3">
Click to view the solution.
</button>
</h2>
<div id="collapse6_3" class="accordion-collapse collapse"
aria-labelledby="heading6_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Sentence 4</p>
<p>Remember, our corpus was:</p>
<div id="cb1" class="sourceCode">
<pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a aria-hidden="true" href="#cb1-1" tabindex="-1"></a>[<span class="st">"is"</span>, <span class="st">"the"</span>, <span class="st">"college"</span>, <span class="st">"board"</span>, <span class="st">"the"</span>, <span class="st">"board"</span>, <span class="st">"of"</span>, <span class="st">"college"</span>]</span></code></pre>
</div>
<p>In order for a sentence to be sampled, it must be made up of bigrams
that appeared in the corpus. This automatically rules out Sentence 1,
because <code>"of the"</code> never appears in the corpus and Sentence
5, because <code>"board is"</code> never appears in the corpus.</p>
<p>Then, let’s compute the probabilities of the other three
sentences:</p>
<p>Sentence 2:</p>
<p><span class="math display">\begin{align*} P(\text{the board the board
the}) &amp;= P(\text{the}) \cdot P(\text{board | the}) \cdot P(\text{the
| board}) \cdot P(\text{board | the}) \cdot P(\text{the | board}) \\
&amp;= \frac{2}{8} \cdot \frac{1}{2} \cdot \frac{1}{2} \cdot \frac{1}{2}
\cdot \frac{1}{2} \\ &amp;= \frac{1}{64}
\end{align*}</span></p>
<p>Sentence 3:</p>
<p><span class="math display">\begin{align*} P(\text{board the college
board of}) &amp;= P(\text{board}) \cdot P(\text{the | board}) \cdot
P(\text{college | the}) \cdot P(\text{board | college}) \cdot P(\text{of
| board}) \\
&amp;= \frac{2}{8} \cdot \frac{1}{2} \cdot \frac{1}{2} \cdot \frac{1}{2}
\cdot \frac{1}{2} \\ &amp;= \frac{1}{64}\end{align*}</span></p>
<p>Sentence 4:</p>
<p><span class="math display">\begin{align*} P(\text{the college board
of college}) &amp;= P(\text{the}) \cdot P(\text{college | the}) \cdot
P(\text{board | college}) \cdot P(\text{of | board}) \cdot
P(\text{college | of}) \\
&amp;= \frac{2}{8} \cdot \frac{1}{2} \cdot 1 \cdot \frac{1}{2} \cdot 1
\\ &amp;= \frac{1}{16} \end{align*}</span></p>
<p>Thus, Sentence 4 is most likely to be sampled.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 72%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>For your convenience, we repeat the same five sentences again
below.</p>
<ul>
<li><pre><code>&quot;of the college board the&quot;</code></pre></li>
<li><pre><code>&quot;the board the board the&quot;</code></pre></li>
<li><pre><code>&quot;board the college board of&quot;</code></pre></li>
<li><pre><code>&quot;the college board of college&quot;</code></pre></li>
<li><pre><code>&quot;board the college board is&quot;</code></pre></li>
</ul>
<p>Suppose we create a TF-IDF matrix, in which there is one row for each
sentence and one column for each unique word. The value in row <span
class="math inline">i</span> and column <span
class="math inline">j</span> is the TF-IDF of word <span
class="math inline">j</span> in sentence <span
class="math inline">i</span>. Note that since there are 5 sentences and
5 unique words across all sentences, the TF-IDF matrix has 25 total
values.</p>
<p><br></p>
<h3 id="problem-6.4">Problem 6.4</h3>
<p>Is there a column in the TF-IDF matrix in which all values are 0?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Yes</p></li>
<li><p><input type="radio" disabled="" /> No</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_4" aria-expanded="true" aria-controls="collapse6_4">
Click to view the solution.
</button>
</h2>
<div id="collapse6_4" class="accordion-collapse collapse"
aria-labelledby="heading6_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Yes</p>
<p>Recall,</p>
<p><span class="math display">\text{tf-idf}(t, d) = \text{term
frequency}(t, d) \cdot \text{inverse document frequency}(t)</span></p>
<p>In the context of TF-IDF, if a word appears in every sentence, its
inverse document frequency (IDF) would be <span class="math inline">\log(\frac{5}{5}) = 0</span>. Since a word’s TF-IDF
in a document is its TF (term frequency) in that document multiplied by
its IDF, if the word’s IDF is 0, it’s TF-IDF is also 0. Since “the”
appears in all five sentences, its IDF is zero, leading to a column of
zeros in the TF-IDF matrix for “the”.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 49%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.5">Problem 6.5</h3>
<p>In which of the following sentences is “college” the word with the
highest TF-IDF?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Sentence 1</p></li>
<li><p><input type="radio" disabled="" /> Sentence 2</p></li>
<li><p><input type="radio" disabled="" /> Sentence 3</p></li>
<li><p><input type="radio" disabled="" /> Sentence 4</p></li>
<li><p><input type="radio" disabled="" /> Sentence 5</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_5" aria-expanded="true" aria-controls="collapse6_5">
Click to view the solution.
</button>
</h2>
<div id="collapse6_5" class="accordion-collapse collapse"
aria-labelledby="heading6_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Sentence 4</p>
<p>Remember, the IDF of a word is the same for all documents, since $(t)
= ( )$. This means that the sentence where “college” is the word with
the highest TF-IDF is the same as the sentence where “college” is the
word with the highest TF, or term frequency. Sentence 4 is the only
sentence where “college” appears twice; in all other sentences,
“college” appears at most once. (Since all of these sentences have the
same length, we know that if “college” appears more times in Sentence 4
than it does in other sentences, then “college”’s term frequency in
Sentence 4, <span class="math inline">\frac{2}{5}</span>, is also larger
than in any other sentence.) As such, the answer is Sentence 4.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 95%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-6.6">Problem 6.6</h3>
<p>As an alternative to TF-IDF, Yuxin proposes the DF-ITF, or “document
frequency-inverse term frequency”. The DF-ITF of term <span
class="math inline">t</span> in document <span
class="math inline">d</span> is defined below:</p>
<p><span class="math display">\text{df-itf}(t, d) = \frac{\text{\# of
documents in which $t$ appears}}{\text{total \# of documents}} \cdot
\log \left( \frac{\text{total \# of words in $d$}}{\text{\# of
occurrences of $t$ in $d$}} \right)</span></p>
<p>Fill in the blank: The term <span class="math inline">t</span> in
document <span class="math inline">d</span> that best summarizes
document <span class="math inline">d</span> is the term with ____.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> the largest DF-ITF in document <span class="math inline">d</span></p></li>
<li><p><input type="radio" disabled="" /> the smallest DF-ITF in document <span class="math inline">d</span></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading6_6">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse6_6" aria-expanded="true" aria-controls="collapse6_6">
Click to view the solution.
</button>
</h2>
<div id="collapse6_6" class="accordion-collapse collapse"
aria-labelledby="heading6_6" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> the smallest DF-IDF in document <span class="math inline">d</span></p>
<p>The key idea behind TF-IDF, as we learned in class, is that <span class="math inline">t</span> is a good summary of <span class="math inline">d</span> if <span class="math inline">t</span>
occurs commonly in <span class="math inline">d</span> but rarely across
all documents.</p>
<p>When <span class="math inline">t</span> occurs often in <span class="math inline">d</span>, then <span class="math inline">\frac{\text{\# of occurrences of $t$ in
$d$}}{\text{total \# of words in $d$}}</span> is large, which means
<span class="math inline">\frac{\text{total \# of words in
$d$}}{\text{\# of occurrences of $t$ in $d$}}</span> and hence <span class="math inline">\log \left( \frac{\text{total \# of words in
$d$}}{\text{\# of occurrences of $t$ in $d$}} \right)</span> is
small.</p>
<p>Similarly, if <span class="math inline">t</span> is rare across all
documents, then <span class="math inline">\frac{\text{\# of documents in
which $t$ appears}}{\text{total \# of documents}}</span> is small.</p>
<p>Putting the above two pieces together, we have that <span class="math inline">\text{df-itf}(t, d)</span> is small when <span class="math inline">t</span> occurs commonly in <span class="math inline">d</span> but rarely overall, which means that the
term <span class="math inline">t</span> that best summarizes <span class="math inline">d</span> is the term with the smallest DF-IDF in
<span class="math inline">d</span>.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 90%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-7">Problem 7</h2>
<p>We decide to build a classifier that takes in a state’s demographic
information and predicts whether, in a given year:</p>
<ul>
<li><p>The state’s mean math score was greater than its mean verbal
score (1), or</p></li>
<li><p>the state’s mean math score was less than or equal to its mean
verbal score (0).</p></li>
</ul>
<p><br></p>
<h3 id="problem-7.1">Problem 7.1</h3>
<p>The simplest possible classifier we could build is one that predicts
the same label (1 or 0) every time, independent of all other
features.</p>
<p>Consider the following statement:</p>
<p><em>If <code>a &gt; b</code>, then the constant classifier that
maximizes training accuracy predicts 1 every time; otherwise, it
predicts 0 every time.</em></p>
<p>For which combination of <code>a</code> and <code>b</code> is the
above statement <strong>not guaranteed</strong> to be true?</p>
<p><em>Note: Treat <code>sat</code> as our training set.</em></p>
<p>Option 1:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> (sat[<span class="st">&#39;Math&#39;</span>] <span class="op">&gt;</span> sat[<span class="st">&#39;Verbal&#39;</span>]).mean()</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fl">0.5</span></span></code></pre></div>
<p>Option 2:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> (sat[<span class="st">&#39;Math&#39;</span>] <span class="op">-</span> sat[<span class="st">&#39;Verbal&#39;</span>]).mean()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">0</span></span></code></pre></div>
<p>Option 3:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> (sat[<span class="st">&#39;Math&#39;</span>] <span class="op">-</span> sat[<span class="st">&#39;Verbal&#39;</span>] <span class="op">&gt;</span> <span class="dv">0</span>).mean()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fl">0.5</span></span></code></pre></div>
<p>Option 4:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> ((sat[<span class="st">&#39;Math&#39;</span>] <span class="op">/</span> sat[<span class="st">&#39;Verbal&#39;</span>]) <span class="op">&gt;</span> <span class="dv">1</span>).mean() <span class="op">-</span> <span class="fl">0.5</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="dv">0</span></span></code></pre></div>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Option 1</p></li>
<li><p><input type="radio" disabled="" /> Option 2</p></li>
<li><p><input type="radio" disabled="" /> Option 3</p></li>
<li><p><input type="radio" disabled="" /> Option 4</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_1" aria-expanded="true" aria-controls="collapse7_1">
Click to view the solution.
</button>
</h2>
<div id="collapse7_1" class="accordion-collapse collapse"
aria-labelledby="heading7_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 2</p>
<p>Conceptually, we’re looking for a combination of <code>a</code> and
<code>b</code> such that when <code>a &gt; b</code>, it’s true that
<strong>in more than 50% of states, the <code>"Math"</code> value is
larger than the <code>"Verbal"</code> value</strong>. Let’s look at all
four options through this lens:</p>
<ul>
<li>Option 1: <code>sat['Math'] &gt; sat['Verbal']</code> is a Series of
Boolean values, containing <code>True</code> for all states where the
<code>"Math"</code> value is larger than the <code>"Verbal"</code> value
and <code>False</code> for all other states. The mean of this series,
then, is the proportion of states satisfying this criteria, and since
<code>b</code> is <code>0.5</code>, <code>a &gt; b</code> is
<code>True</code> only when the bolded condition above is
<code>True</code>.</li>
<li>Option 3 is the same as Option 1 – note that <span class="math inline">x &gt; y</span> is equivalent to <span class="math inline">x - y &gt; 0</span>.</li>
<li>Option 4: <code>sat['Math'] / sat['Verbal']</code> is a Series that
contains values greater than 1 whenever a state’s <code>"Math"</code>
value is larger than its <code>"Verbal"</code> value and less than or
equal to 1 in all other cases. As in the other options that work,
<code>(sat['Math'] / sat['Verbal']) &gt; 1</code> is a Boolean Series
with <code>True</code> for all states with a larger <code>"Math"</code>
value than <code>"Verbal"</code> values; <code>a &gt; b</code> compares
the proportion of <code>True</code> values in this Series to 0.5. (Here,
<span class="math inline">p - 0.5 &gt; 0</span> is the same as <span class="math inline">p &gt; 0.5</span>.)</li>
</ul>
<p>Then, by process of elimination, Option 2 must be the correct option
– that is, it must be the only option that <strong>doesn’t</strong>
work. But why? <code>sat['Math'] - sat['Verbal']</code> is a Series
containing the difference between each state’s <code>"Math"</code> and
<code>"Verbal"</code> values, and <code>.mean()</code> computes the mean
of these differences. The issue is that here, we don’t care about
<em>how different</em> each state’s <code>"Math"</code> and
<code>"Verbal"</code> values are; rather, we just care about the
proportion of states with a bigger <code>"Math"</code> value than
<code>"Verbal"</code> value. It could be the case that 90% of states
have a larger <code>"Math"</code> value than <code>"Verbal"</code>
value, but one state has such a big <code>"Verbal"</code> value that it
makes the mean difference between <code>"Math"</code> and
<code>"Verbal"</code> scores negative. (A property you’ll learn about in
future probability courses is that this is equal to the difference in
the mean <code>"Math"</code> value for all states and the mean
<code>"Verbal"</code> value for all states – this is called the
“linearity of expectation” – but you don’t need to know that to answer
this question.)</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 58%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.2">Problem 7.2</h3>
<p>Suppose we train a classifier, named Classifier 1, and it achieves an
accuracy of <span class="math inline">\frac{5}{9}</span> on our training
set.</p>
<p>Typically, root mean squared error (RMSE) is used as a performance
metric for regression models, but mathematically, nothing is stopping us
from using it as a performance metric for classification models as
well.</p>
<p>What is the RMSE of Classifier 1 on our training set? Give your
answer as a <strong>simplified fraction</strong>.</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_2" aria-expanded="true" aria-controls="collapse7_2">
Click to view the solution.
</button>
</h2>
<div id="collapse7_2" class="accordion-collapse collapse"
aria-labelledby="heading7_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <span class="math inline">\frac{2}{3}</span></p>
<p>An accuracy of <span class="math inline">\frac{5}{9}</span> means
that the model is such that out of 9 values, 5 are labeled correctly. By
extension, this means that 4 out of 9 are not labeled correctly as 0 or
1.</p>
<p>Remember, RMSE is defined as</p>
<p><span class="math display">\text{RMSE} = \sqrt{\frac{1}{n} \sum_{i =
1}^n (y_i - H(x_i))^2}</span></p>
<p>where <span class="math inline">y_i</span> represents the <span class="math inline">i</span>th actual value and <span class="math inline">H(x_i)</span> represents the <span class="math inline">i</span>th prediction. Here, <span class="math inline">y_i</span> is either 0 or 1 and $H(x_i) is also
either 0 or 1. We’re told that <span class="math inline">\frac{5}{9}</span> of the time, <span class="math inline">y_i</span> and <span class="math inline">H(x_i)</span> are the same; in those cases, <span class="math inline">(y_i - H(x_i))^2 = 0^2 = 0</span>. We’re also told
that <span class="math inline">\frac{4}{9}</span> of the time, <span class="math inline">y_i</span> and <span class="math inline">H(x_i)</span> are different; in those cases, <span class="math inline">(y_i - H(x_i))^2 = 1</span>. So,</p>
<p><span class="math display">\text{RMSE} = \sqrt{\frac{5}{9} \cdot 0 +
\frac{4}{9} \cdot 1} = \sqrt{\frac{4}{9}} = \frac{2}{3}</span></p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 55%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.3">Problem 7.3</h3>
<p>While Classifier 1’s accuracy on our training set is <span
class="math inline">\frac{5}{9}</span>, its accuracy on our test set is
<span class="math inline">\frac{1}{4}</span>. Which of the following
scenarios is most likely?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Classifier 1 overfit to our training set; we need to increase its
complexity.</p></li>
<li><p><input type="radio" disabled="" /> Classifier 1 overfit to our training set; we need to decrease its
complexity.</p></li>
<li><p><input type="radio" disabled="" /> Classifier 1 underfit to our training set; we need to increase its
complexity.</p></li>
<li><p><input type="radio" disabled="" /> Classifier 1 underfit to our training set; we need to decrease its
complexity.</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_3" aria-expanded="true" aria-controls="collapse7_3">
Click to view the solution.
</button>
</h2>
<div id="collapse7_3" class="accordion-collapse collapse"
aria-labelledby="heading7_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 2</p>
<p>Since the accuracy of Classifier 1 is much higher on the dataset used
to train it than the dataset it was tested on, it’s likely Classifer 1
overfit to the training set because it was too complex. To fix the
issue, we need to decrease its complexity, so that it focuses on
learning the general structure of the data in the training set and not
too much on the random noise in the training set.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 86%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>For the remainder of this question, suppose we train another
classifier, named Classifier 2, again on our training set. Its
performance on the training set is described in the confusion matrix
below. Note that the columns of the confusion matrix have been
separately normalized so that each has a sum of 1.</p>
<center><img src='../assets/images/wi23-final/conf-matrix.png' width=30%></center>
<p><br></p>
<h3 id="problem-7.4">Problem 7.4</h3>
<p>Suppose <code>conf</code> is the DataFrame above. Which of the
following evaluates to a Series of length 2 whose only unique value is
the number <code>1</code>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>conf.sum(axis=0)</code></p></li>
<li><p><input type="radio" disabled="" /> <code>conf.sum(axis=1)</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_4" aria-expanded="true" aria-controls="collapse7_4">
Click to view the solution.
</button>
</h2>
<div id="collapse7_4" class="accordion-collapse collapse"
aria-labelledby="heading7_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 1</p>
<p>Note that the columns of <code>conf</code> sum to 1 – <span class="math inline">0.9 + 0.1 = 1</span>, and <span class="math inline">0.4 + 0.6 = 1</span>. To create a Series with just
the value 1, then, we need to sum the columns of <code>conf</code>,
which we can do using <code>conf.sum(axis=0)</code>.
<code>conf.sum(axis=1)</code> would sum the rows of
<code>conf</code>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 81%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-7.5">Problem 7.5</h3>
<p>Fill in the blank: the ___ of Classifier 2 is guaranteed to be
0.6.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> precision</p></li>
<li><p><input type="radio" disabled="" /> recall</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_5">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_5" aria-expanded="true" aria-controls="collapse7_5">
Click to view the solution.
</button>
</h2>
<div id="collapse7_5" class="accordion-collapse collapse"
aria-labelledby="heading7_5" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> recall</p>
<p>The number 0.6 appears in the bottom-right corner of
<code>conf</code>. Since <code>conf</code> is column-normalized, the
value 0.6 represents the proportion of values in the second column that
were predicted to be 1. The second column contains values that were
actually 1, so 0.6 is really <strong>the proportion of values that were
actually 1 that were predicted to be 1</strong>, that is, <span class="math inline">\frac{\text{actually 1 and predicted
1}}{\text{actually 1}}</span>. This is the definition of recall!</p>
<p>If you’d like to think in terms of true positives, etc., then
remember that: - True Positives (TP) are values that were actually 1 and
were predicted to be 1. - True Negatives (TN) are values that were
actually 0 and were predicted to be 0. - False Positives (FP) are values
that were actually 0 and were predicted to be 1. - False Negatives (FN)
are values that were actually 1 and were predicted to be 0.</p>
<p>Recall is <span class="math inline">\frac{\text{TP}}{\text{TP} +
\text{FN}}</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 77%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p>For your convenience, we show the column-normalized confusion matrix
from the previous page below. You will need to use the specific numbers
in this matrix when answering the following subpart.</p>
<center><img src='../assets/images/wi23-final/conf-matrix.png' width=30%></center>
<p><br></p>
<h3 id="problem-7.6">Problem 7.6</h3>
<p>Suppose a fraction <span class="math inline">\alpha</span> of the
labels in the training set are actually 1 and the remaining <span
class="math inline">1 - \alpha</span> are actually 0. The accuracy of
Classifier 2 is 0.65. What is the value of <span
class="math inline">\alpha</span>? </p>
<p>Hint: If you’re unsure on how to proceed, here are some guiding
questions:</p>
<ul>
<li><p>Suppose the number of <span class="math inline">y</span>-values
that are actually 1 is <span class="math inline">A</span> and that the
number of <span class="math inline">y</span>-values that are actually 0
is <span class="math inline">B</span>. In terms of <span
class="math inline">A</span> and <span class="math inline">B</span>,
what is the accuracy of Classifier 2? Remember, you’ll need to refer to
the numbers in the confusion matrix above.</p></li>
<li><p>What is the relationship between <span
class="math inline">A</span>, <span class="math inline">B</span>, and
<span class="math inline">\alpha</span>? How does it simplify your
calculation for the accuracy in the previous step?</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading7_6">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse7_6" aria-expanded="true" aria-controls="collapse7_6">
Click to view the solution.
</button>
</h2>
<div id="collapse7_6" class="accordion-collapse collapse"
aria-labelledby="heading7_6" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <span class="math inline">\frac{5}{6}</span></p>
<p>Here is one way to solve this problem:</p>
<p>accuracy = <span class="math inline">\frac{TP + TN}{TP + TN + FP +
FN}</span></p>
<p>Given the values from the confusion matrix:</p>
<p>accuracy = <span class="math inline">\frac{0.6 \cdot \alpha + 0.9
\cdot (1 - \alpha)}{\alpha + (1 - \alpha)}</span><br/>
accuracy = <span class="math inline">\frac{0.6 \cdot \alpha + 0.9 - 0.9
\cdot \alpha}{1}</span><br/>
accuracy = <span class="math inline">0.9 - 0.3 \cdot \alpha</span></p>
<p>Therefore:</p>
<p>0.65 = <span class="math inline">0.9 - 0.3 \cdot \alpha</span><br/>
<span class="math inline">0.3 \cdot \alpha</span> = <span class="math inline">0.9 - 0.65</span><br/>
<span class="math inline">0.3 \cdot \alpha</span> = <span class="math inline">0.25</span><br/>
<span class="math inline">\alpha</span> = <span class="math inline">\frac{0.25}{0.3}</span><br/>
<span class="math inline">\alpha</span> = <span class="math inline">\frac{5}{6}</span></p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 61%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-8">Problem 8</h2>
<p>Let’s continue with the premise from the previous question. That is,
we will aim to build a classifier that takes in demographic information
about a state from a particular year and predicts whether or not the
state’s mean math score is higher than its mean verbal score that
year.</p>
<p>In honor of the
<a href="https://www.reddit.com/r/UCSD/comments/11o0w9r/chicken_event/">rotisserie
chicken event</a> on UCSD’s campus a few weeks ago, <code>sklearn</code>
released a new classifier class called
<code>ChickenClassifier</code>.</p>
<p><br></p>
<h3 id="problem-8.1">Problem 8.1</h3>
<p><code>ChickenClassifier</code>s have many hyperparameters, one of
which is <code>height</code>. As we increase the value of
<code>height</code>, the model variance of the resulting
<code>ChickenClassifier</code> also increases.</p>
<p>First, we consider the training and testing accuracy of a
<code>ChickenClassifier</code> trained using various values of
<code>height</code>. Consider the plot below.</p>
<center><img src='../assets/images/wi23-final/accuracy.png' width=30%></center>
<p>Which of the following depicts <strong>training accuracy
vs. <code>height</code></strong>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Option 1</p></li>
<li><p><input type="radio" disabled="" /> Option 2</p></li>
<li><p><input type="radio" disabled="" /> Option 3</p></li>
</ul>
<p>Which of the following depicts <strong>testing accuracy
vs. <code>height</code></strong>?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> Option 1</p></li>
<li><p><input type="radio" disabled="" /> Option 2</p></li>
<li><p><input type="radio" disabled="" /> Option 3</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading8_1">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse8_1" aria-expanded="true" aria-controls="collapse8_1">
Click to view the solution.
</button>
</h2>
<div id="collapse8_1" class="accordion-collapse collapse"
aria-labelledby="heading8_1" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> Option 2 depicts training accuracy
vs. <code>height</code>; Option 3 depicts testing accuract
vs. <code>height</code></p>
<p>We are told that as <code>height</code> increases, the model variance
(complexity) also increases.</p>
<p>As we increase the complexity of our classifier, it will do a better
job of fitting to the training set because it’s able to “memorize” the
patterns in the training set. As such, as <code>height</code> increases,
training accuracy increases, which we see in Option 2.</p>
<p>However, after a certain point, increasing <code>height</code> will
make our classifier overfit too closely to our training set and not
general enough to match the patterns in other similar datasets, meaning
that after a certain point, increasing <code>height</code> will actually
decrease our classifier’s accuracy on our testing set. The only option
that shows accuracy increase and then decrease is Option 3.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 75%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<p><code>ChickenClassifier</code>s have another hyperparameter,
<code>color</code>, for which there are four possible values:
<code>"yellow"</code>, <code>"brown"</code>, <code>"red"</code>, and
<code>"orange"</code>. To find the optimal value of <code>color</code>,
we perform <span class="math inline">k</span>-fold cross-validation with
<span class="math inline">k=4</span>. The results are given in the table
below.</p>
<center><img src='../assets/images/wi23-final/CV.png' width=30%></center>
<p><br></p>
<h3 id="problem-8.2">Problem 8.2</h3>
<p>Which value of <code>color</code> has the best average validation
accuracy?</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <code>"yellow"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"brown"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"red"</code></p></li>
<li><p><input type="radio" disabled="" /> <code>"orange"</code></p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading8_2">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse8_2" aria-expanded="true" aria-controls="collapse8_2">
Click to view the solution.
</button>
</h2>
<div id="collapse8_2" class="accordion-collapse collapse"
aria-labelledby="heading8_2" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> <code>"red"</code></p>
<p>From looking at the results of the k-fold cross validation, we see
that the color red has the highest, and therefore the best, validation
accuracy as it has the highest row mean (across all 4 folds).</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 91%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-8.3">Problem 8.3</h3>
<p>True or False: It is possible for a hyperparameter value to have the
best average validation accuracy across all folds, but not have the best
validation accuracy in any one particular fold.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> True</p></li>
<li><p><input type="radio" disabled="" /> False</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading8_3">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse8_3" aria-expanded="true" aria-controls="collapse8_3">
Click to view the solution.
</button>
</h2>
<div id="collapse8_3" class="accordion-collapse collapse"
aria-labelledby="heading8_3" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer:</strong> True</p>
<p>An example is shown below:</p>
<table>
<thead>
<tr class="header">
<th>color</th>
<th>Fold 1</th>
<th>Fold 2</th>
<th>Fold 3</th>
<th>Fold 4</th>
<th>average</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>color 1</td>
<td>0.8</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.2</td>
</tr>
<tr class="even">
<td>color 2</td>
<td>0</td>
<td>0.6</td>
<td>0</td>
<td>0</td>
<td>0.15</td>
</tr>
<tr class="odd">
<td>color 3</td>
<td>0</td>
<td>0</td>
<td>0.1</td>
<td>0</td>
<td>0.025</td>
</tr>
<tr class="even">
<td>color 4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.2</td>
<td>0.05</td>
</tr>
<tr class="odd">
<td>color 5</td>
<td>0.7</td>
<td>0.5</td>
<td>0.01</td>
<td>0.1</td>
<td>0.3275</td>
</tr>
</tbody>
</table>
<p>In the example, color 5 has the highest average validation accuracy
across all folds, but is not the best in any one fold.</p>
<hr/>
<h5>Difficulty: ⭐️</h5>
<p>
<p>The average score on this problem was 94%.</p>
</p>
</div>
</div>
</div>
</div>
<p><br></p>
<h3 id="problem-8.4">Problem 8.4</h3>
<p>Now, instead of finding the best <code>height</code> and best
<code>color</code> individually, we decide to perform a grid search that
uses <span class="math inline">k</span>-fold cross-validation to find
the combination of <code>height</code> and <code>color</code> with the
best average validation accuracy.</p>
<p>For the purposes of this question, assume that:</p>
<ul>
<li>We are performing <span class="math inline">k</span>-fold cross
validation.</li>
<li>Our training set contains <span class="math inline">n</span> rows,
where <span class="math inline">n</span> is greater than 5 and is a
multiple of <span class="math inline">k</span>.</li>
<li>There are <span class="math inline">h_1</span> possible values of
<code>height</code> and <span class="math inline">h_2</span> possible
values of <code>color</code>.</li>
</ul>
<p>Consider the following three subparts:</p>
<ul>
<li>A. What is the size of each fold?</li>
<li>B. How many times is row 5 in the training set used for
training?</li>
<li>C. How many times is row 5 in the training set used for
validation?</li>
</ul>
<p>Choose from the following options.</p>
<ul class="task-list">
<li><p><input type="radio" disabled="" /> <span class="math inline">k</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\frac{k}{n}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\frac{n}{k}</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\frac{n}{k} \cdot (k - 1)</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">h_1h_2k</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">h_1h_2(k-1)</span></p></li>
<li><p><input type="radio" disabled="" /> <span class="math inline">\frac{nh_1h_2}{k}</span></p></li>
<li><p><input type="radio" disabled="" /> None of the above</p></li>
</ul>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading8_4">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse8_4" aria-expanded="true" aria-controls="collapse8_4">
Click to view the solution.
</button>
</h2>
<div id="collapse8_4" class="accordion-collapse collapse"
aria-labelledby="heading8_4" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> A: Option 3 (<span class="math inline">\frac{n}{k}</span>), B: Option 6 (<span class="math inline">h_1h_2(k-1)</span>), C: Option 8 (None of the
above)</p>
<p><br/></p>
<h5 id="a.-what-is-the-size-of-each-fold">A. What is the size of each
fold?</h5>
<p>The training set is divided into <span class="math inline">k</span>
folds of equal size, resulting in <span class="math inline">k</span>
folds with size <span class="math inline">\frac{n}{k}</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 66%.</p>
<p><br/></p>
<h5 id="b.-how-many-times-is-row-5-in-the-training-set-used-for-training">B.
How many times is row 5 in the training set used for training?</h5>
<p>For each combination of hyperparameters, row 5 is <span class="math inline">k - 1</span> times for training and <span class="math inline">1</span> time for validation. There are <span class="math inline">h_1 \cdot h_2</span> combinations of
hyperparameters, so row 5 is used for training <span class="math inline">h_1 \cdot h_2 \cdot (k-1)</span> times.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️</h5>
<p>
<p>The average score on this problem was 76%.</p>
<p><br/></p>
<h5 id="c.-how-many-times-is-row-5-in-the-training-set-used-for-validation">C.
How many times is row 5 in the training set used for validation?</h5>
<p>Building off of the explanation for the previous subpart, row 5 is
used for validation 1 times for each combination of hyperparameters, so
the correct expression would be <span class="math inline">h_1 \cdot
h_2</span>, which is not a provided option.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 69%.</p>
</p></p></p>
</div>
</div>
</div>
</div>
<p><br></p>
<hr />
<h2 id="problem-9">Problem 9</h2>
<p>One piece of information that may be useful as a feature is the
proportion of SAT test takers in a state in a given year that qualify
for free lunches in school. The Series <code>lunch_props</code> contains
8 values, each of which are either <code>"low"</code>,
<code>"medium"</code>, or <code>"high"</code>. Since we can’t use
strings as features in a model, we decide to encode these strings using
the following <code>Pipeline</code>:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: The FunctionTransformer is only needed to change the result</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co"># of the OneHotEncoder from a &quot;sparse&quot; matrix to a regular matrix</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co"># so that it can be used with StandardScaler;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co"># it doesn&#39;t change anything mathematically.</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>pl <span class="op">=</span> Pipeline([</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;ohe&quot;</span>, OneHotEncoder(drop<span class="op">=</span><span class="st">&quot;first&quot;</span>)),</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;ft&quot;</span>, FunctionTransformer(<span class="kw">lambda</span> X: X.toarray())),</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;ss&quot;</span>, StandardScaler())</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>])</span></code></pre></div>
<p>After calling <code>pl.fit(lunch_props)</code>,
<code>pl.transform(lunch_props)</code> evaluates to the following
array:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>array([[ <span class="fl">1.29099445</span>, <span class="op">-</span><span class="fl">0.37796447</span>],</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>       [<span class="op">-</span><span class="fl">0.77459667</span>, <span class="op">-</span><span class="fl">0.37796447</span>],</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>       [<span class="op">-</span><span class="fl">0.77459667</span>, <span class="op">-</span><span class="fl">0.37796447</span>],</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>       [<span class="op">-</span><span class="fl">0.77459667</span>,  <span class="fl">2.64575131</span>],</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>       [ <span class="fl">1.29099445</span>, <span class="op">-</span><span class="fl">0.37796447</span>],</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>       [ <span class="fl">1.29099445</span>, <span class="op">-</span><span class="fl">0.37796447</span>],</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>       [<span class="op">-</span><span class="fl">0.77459667</span>, <span class="op">-</span><span class="fl">0.37796447</span>],</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>       [<span class="op">-</span><span class="fl">0.77459667</span>, <span class="op">-</span><span class="fl">0.37796447</span>]])</span></code></pre></div>
<p>and <code>pl.named_steps["ohe"].get_feature_names()</code> evaluates
to the following array:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>array([<span class="st">&quot;x0_low&quot;</span>, <span class="st">&quot;x0_med&quot;</span>], dtype<span class="op">=</span><span class="bu">object</span>)</span></code></pre></div>
<p>Fill in the blanks: Given the above information, we can conclude that
<code>lunch_props</code> has <strong>(a)</strong> value(s) equal to
<code>"low"</code>, <strong>(b)</strong> value(s) equal to
<code>"medium"</code>, and <strong>(c)</strong> value(s) equal to
<code>"high"</code>. <em>(Note: You should write one positive integer in
each box such that the numbers add up to 8.)</em></p>
<p>What goes in the blanks?</p>
<div id="accordionExample" class="accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="heading9">
<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse9" aria-expanded="true" aria-controls="collapse9">
Click to view the solution.
</button>
</h2>
<div id="collapse9" class="accordion-collapse collapse"
aria-labelledby="heading9" data-bs-parent="#accordionExample">
<div class="accordion-body">
<header id="title-block-header">
<h1 class="title"> </h1>
</header>
<p><strong>Answer: </strong> 3, 1, 4</p>
<p>The first column of the transformed array corresponds to the
standardized one-hot-encoded <code>low</code> column. There are 3 values
that are positive, which means there are 3 values that were originally
<code>1</code> in that column pre-standardization. This means that 3 of
the values in <code>lunch_props</code> were originally
<code>"low"</code>.</p>
<p>The second column of the transformed array corresponds to the
standardized one-hot-encoded <code>med</code> column. There is only 1
value in the transformed column that is positive, which means only 1 of
the values in <code>lunch_props</code> was originally
<code>"medium"</code>.</p>
<p>The Series <code>lunch_props</code> has 8 values, 3 of which were
identified as <code>"low"</code> in subpart 1, and 1 of which was
identified as <code>"medium"</code> in subpart 2. The number of values
being <code>"high"</code> must therefore be <span class="math inline">8
- 3 - 1 = 4</span>.</p>
<hr/>
<h5>Difficulty: ⭐️⭐️⭐️</h5>
<p>
<p>The average score on this problem was 73%.</p>
</p>
</div>
</div>
</div>
</div>
<hr />
<h2 id="section"><span class="math display"> </span></h2>
<h4
id="feedback-find-an-error-still-confused-have-a-suggestion-let-us-know-here.">👋
Feedback: Find an error? Still confused? Have a suggestion?
<a href="https://forms.gle/WZ71FchnXU1K154d7">Let us know
here</u></a>.</h4>
<hr />
</body>
</html>
